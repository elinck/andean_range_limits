---
title: "Andean bird blood data exploration"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Introduction

What constrains elevational range limits in the absence of an ecotone or obvious biotic constraints? One *abiotic* factor that falls under what Terborgh& Weske (1975) called constraints that vary "continuously and in parallel with the elevational gradient" is the partial pressure of oxygen (PO2), which declines roughly linearly with altitude and is an strong selective pressure.

```{r, echo=FALSE, warning=FALSE, fig.height=3,fig.width=4}
library(ggplot2)
p <- function(x) 760*exp(-(0.0289644*9.81)/(8.3143*288.15)*x)

ggplot(data = data.frame(x = 0), mapping = aes(x = x)) +
  theme_bw() +
  stat_function(fun = p, aes(linetype="mmHg"),color="red") +
  scale_linetype_discrete(guide=FALSE) +
  theme(panel.grid = element_blank()) +
  ylab("mmHg") +
  xlim(0,8000) +
  ylim(0,1000) +
  xlab("Elevation (m)") +
  ylab("Atmospheric pressure (mmHg)")
```

In this analysis, we're using a large dataset of blood trait values (total blood hemoglobin concentration, haematocrit, or the volume percentage of red blood cells in blood, and MCHC, or mean cellular hemoglobin concentration) to try and understand a little bit better why tropical birds have such narrow elevational ranges. How narrow, you ask? Here's a visualization of the distribution of elevational range breadth using data from the 3,752 neotropical bird  species in [Parker et al. 1996](https://www.press.uchicago.edu/ucp/books/book/chicago/E/bo3618705.html) (what Chris calls the "Stotz" data)".

```{r, message=FALSE, warning=FALSE}
# load libraries
library(tidyverse, quietly = TRUE)
library(magrittr)
library(ape)
library(phangorn)
library(nlme)
library(phytools)
library(cowplot)
library(mapdata)

# load functions script
source("~/Dropbox/andean_range_limits/scripts/00_functions.R")

# load stotz data
stotz <- read.csv("~/Dropbox/andean_range_limits/data/stotz_elevation_data.csv")
stotz <- cbind.data.frame(stotz$GENUS, stotz$SPECIES, 
                          stotz$MIN, stotz$MAX, stotz$MIDPT.ELEV)
colnames(stotz) <- c("genus","species","elev_min","elev_max","elev_midpt")
stotz$elev_range <- stotz$elev_max - stotz$elev_min
stotz_mod <- stotz[stotz$elev_range>0,]
```
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=7}
ggplot(stotz_mod, aes(x=elev_range)) +
  geom_histogram(binwidth = 100, color="black",fill="gray70") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        panel.grid = element_blank()) +
  xlab("elevational range breadth")  +
  geom_vline(xintercept = median(stotz$elev_range, na.rm=TRUE),
             linetype="dashed",size=1.5, color="red")

```

Quite narrow, with strong left skew and a median elevational range breadth of 1100 m.

More specifically, we're interested in the following questions: 

1) Is a species' elevational range breadth associated the rate of change (slope) of its blood trait values a cross elevation?

2) Is a species' elevational range breadth associated the total variance of its blood trait values?

3) Is the median elevation of a species' range associated with either of these variables?

To begin, we're going to load our data, take a look at it, and make some filtering choices.  

```{r, message=FALSE, warning=FALSE}
# load data
blood_df <- read.csv("~/Dropbox/andean_range_limits/data/blood_data.csv", 
                     stringsAsFactors = FALSE)

# subset columns of interest
blood_df <- cbind.data.frame(blood_df$Scientific.name, 
                             blood_df$Elevation, 
                             blood_df$Bursa,
                             blood_df$Mass.for.analyses, 
                             blood_df$tHbcorr,
                             blood_df$HctBestEstimate,
                             blood_df$Latitude..degrees.S, 
                             blood_df$Latitude.minutes,
                             blood_df$Longitude.degrees.W, 
                             blood_df$Longitude.minutes,
                             blood_df$Sex)

colnames(blood_df) <- c("species","elevation","bursa","mass","hb","hct", "lat_degrees",
                        "lat_minutes", "long_degrees", "long_minutes", "sex")

# fix longitude minutes error
blood_df$long_minutes <- blood_df$long_minutes %>% as.character() %>% as.numeric()

# fix lat long issue
blood_df$lat <- convert_lat(blood_df)*-1
blood_df$long <- convert_long(blood_df)*-1

# drop sites without locality data 
blood_df <- blood_df[!is.na(blood_df$long),]
blood_df <- blood_df[!is.na(blood_df$lat),]

# drop sites beyond plausible limits of sampling
blood_df <- blood_df[blood_df$lat>(-19),]
blood_df <- blood_df[blood_df$long<(-67),]

# drop old lat long columns
blood_df <- blood_df[,-c(7:10)]

# factor to character nonsense
blood_df$species <- as.character(blood_df$species)
blood_df$elevation <- as.numeric(as.character(blood_df$elevation))
blood_df$hb <-as.numeric(as.character(blood_df$hb))

# drop all missing records (elevation, haemoglobin, haematocrit)
blood_df <- blood_df[!is.na(blood_df$elevation),]
blood_df <- blood_df[!is.na(blood_df$hb),]
blood_df <- blood_df[!is.na(blood_df$hct),]
```

Before we start, where do these records come from, and how are they distributed across elevation?

```{r, echo=FALSE, fig.height=4, fig.width=8}
coast_map <- fortify(map("worldHires", fill=TRUE, plot=FALSE))
c <- ggplot() + coord_map() +
  theme_bw() +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  #geom_map(data=coast_map, map=coast_map, aes(x=long, y=lat, map_id=region), 
  #         fill="white", color="black") +
  geom_map(data=data.frame(region="Peru"), map=coast_map,
                    aes(map_id=region), fill="gray100", col="gray0") + 
  xlim(-82,-68) + 
  ylim(-19,0.5) +
  #geom_point(data=df,aes(x=long, y=lat,fill=elev), colour="black",pch=21,alpha=0.3,size = 0.5) + 
  #scale_fill_gradient(low = "white", high = "black") +
  #xlab("longitude") +
  #ylab("latitude") +
  stat_bin2d(data=blood_df, aes(x=long, y=lat,fill = ..count..), color="black", binwidth = c(0.5,0.5)) +
  scale_fill_gradient(low = "white", high = "black") #name = element_blank())

d <- ggplot(blood_df, aes(x=elevation)) + geom_histogram(binwidth = 100, color="black",fill="gray70") +
  theme_bw() +
  theme(axis.title.y = element_blank()) +
  xlab("elevation (m)")

plot_grid(c, d)
```

Now let's take a look at the head of the dataframe: 

```{r, message=FALSE, warning=FALSE}
# simplified column names
head(blood_df)
```

As you can see, we have columns for species, elevation, presence or absence of a bursa, mass, haemoglobin, haematocrit, collection site longitude and latitude, and sex. As we're also interested in MCHC, let's add a column for that now, using the formula from Campbell and Ellis (thanks, Jessie!)

```{r}
blood_df <- blood_df %>% mutate(hct_percent = hct*100)
blood_df <- blood_df %>% mutate(MCHC_calculated = (hb/hct_percent)*100) # Calculated MCHC
```

Next, let's do some basic filtering, and drop extreme blood parameter values. We'll then drop species with fewer than 8 records: 

```{r,  message=FALSE, warning=FALSE}
blood_df_sub <- blood_df[which(blood_df$hb >= 14 &  blood_df$hb <= 25),]
blood_df_sub <- blood_df_sub[which(blood_df_sub$hct >= 0.35 &  
                                     blood_df_sub$hct <= 0.72),]
blood_df_sub <- blood_df_sub[which(blood_df_sub$MCHC_calculated >= 20 
                                   & blood_df_sub$hct <= 42),] 

sp_list <- c()
for(i in blood_df_sub$species){
  tmp <- blood_df_sub[blood_df_sub$species==i,]
  records <- nrow(tmp)
  if(records > 7){sp_list[i] <- as.character(tmp$species[1])}
}
sp_list <- as.vector(sp_list)

# subset down to "good" species
blood_df_sub <- blood_df_sub[blood_df_sub$species %in% sp_list,]

length(unique(blood_df$species)) # number of unique species before filtering
nrow(blood_df) # number of unique records before filtering
length(unique(blood_df_sub$species)) # number of unique species after filtering
nrow(blood_df_sub) # number of unique records after filtering
```

We'll now merge these data with the Stotz data. We're using the parameter `all.x=TRUE`, which just means we aren't going to drop blood data if there's not a taxonomy match with the Stotz table. 

```{r,  message=FALSE, warning=FALSE}
stotz$binomial <- paste0(stotz$genus, " ", stotz$species) # create single col for sp.
blood_df_stotz <- merge(blood_df_sub, stotz, by.x = "species", by.y = "binomial", 
                        all.x=TRUE)
head(blood_df_stotz)
```

Which species failed to pick up elevational range data?  

```{r,  message=FALSE, warning=FALSE}
blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique() %>% length() 
```

Bummer. Let's take a look them:   
 
```{r,  message=FALSE, warning=FALSE}
missing <- blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
print(missing)
```

All can be explained by taxonomic changes and / or typos. I've gone directly to a copy of the spreadsheet and made the taxonomy of the Stotz data match to avoid errors from manually entering elevations. We'll now merge again, the revised data: 

```{r}
stotz_rev <- read.csv("~/Dropbox/andean_range_limits/data/stotz_elevation_data_rev.csv")
stotz_rev <- cbind.data.frame(stotz_rev$GENUS, stotz_rev$SPECIES, 
                          stotz_rev$MIN, stotz_rev$MAX, stotz_rev$MIDPT.ELEV)
colnames(stotz_rev) <- c("genus","species","elev_min","elev_max","elev_midpt")
stotz_rev$binomial <- paste0(stotz_rev$genus, " ", stotz_rev$species)
blood_df_stotz <- merge(blood_df_sub, stotz_rev, by.x = "species", by.y = "binomial", 
                        all.x=TRUE)
```

Anything still missing?

```{r,  message=FALSE, warning=FALSE}
missing <- blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
length(missing)
```

Yep—let's see  what it is. 

```{r}
blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
```

Unidentified siskins—we'll drop them.

```{r}
blood_df_stotz <- blood_df_stotz[!blood_df_stotz$species=="Spinus sp.",]
```

We'll next apply a filter to drop probable outliers that could have a disproportionate influence on slope estimation, using my custom `outliers_cooks()` function: points with Cook's D of 4/n, or with a Cook's D of 3.5/n if a bursa is present. 

```{r,  message=FALSE, warning=FALSE}
pass_hb <- outliers_cooks(blood_df_stotz, "hb", 4, 3.5)
pass_hct <- outliers_cooks(blood_df_stotz, "hct", 4, 3.5)
pass_mchc <- outliers_cooks(blood_df_stotz, "MCHC_calculated", 4, 3.5)
blood_df_stotz_pass <- intersect(pass_hb, pass_hct, pass_mchc) # get overlapping spp. set
length(unique(blood_df_stotz_pass$species)) # number of unique species
nrow(blood_df_stotz_pass) # retained records
```

For calculating variance down the road, we also need to records based on their relative position in a species' elevational range.

```{r,warning=FALSE}
vardf <- list()
for(i in unique(blood_df_stotz_pass$species)){
  tmp <- blood_df_stotz_pass[blood_df_stotz_pass$species==i,]
  if(tmp$elev_max > max(tmp$elevation)){elev_max <- unique(tmp$elev_max)}
  if(tmp$elev_max < max(tmp$elevation)){elev_max <- max(tmp$elevation)}
  if(tmp$elev_min < min(tmp$elevation)){elev_min <- unique(tmp$elev_min)}
  if(tmp$elev_min > min(tmp$elevation)){elev_min <- min(tmp$elevation)}
  elev_range <- elev_max - elev_min
  tmp$range_position <- 1-((elev_max-tmp$elevation)/elev_range)
  tmp$edge_distance <- 0.5-abs(tmp$range_position-0.5)
  tmp$elev_range <- elev_range
  tmp$elev_min <- elev_min
  tmp$elev_max <- elev_max
  bin_number <- elev_range %/% 100 
  tmp$binID <- cut(tmp$elevation, bin_number)
  vardf[[i]] <- tmp
}
blood_df_stotz_pass <- do.call(rbind, vardf)
```

We're now going to apply a final set of filters to the data (using the function `outliers_limits()`), removing all species with fewer than 2 unique elevational records at least 200 m apart, and fewer than 2 elevational records in the first and last quantile of their range. (This will create the dataframe we'll use for our analysis of the slope of blood parameters—for variance, we'll begin working with a separate dataframe, as we aren't concered with how much of the range these data span.)

```{r,  message=FALSE, warning=FALSE}
blood_df_slope <- outliers_limits(blood_df_stotz_pass, min_sample=2, min_limit=2, 200)
length(unique(blood_df_slope$species)) # number of unique species
nrow(blood_df_slope) # number of unique records
```

Let's visualize these slope data (printing large .pdfs elsewhere):  

```{r, eval=FALSE}
multispecies_hb <- ggplot(blood_df_slope, aes(x=elevation, y=hb)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("hb")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_hb.pdf",width=24,height=20)
multispecies_hb
dev.off()

multispecies_hct <- ggplot(blood_df_slope, aes(x=elevation, y=hct)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("hct")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_hct.pdf",width=24,height=20)
multispecies_hct
dev.off()

multispecies_mchc <- ggplot(blood_df_slope, aes(x=elevation, y=MCHC_calculated)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("mchc")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_mchc.pdf",width=24,height=20)
multispecies_mchc
dev.off()
```

Let's take a quick look at patterns in genera with more than two species. First, we'll subset the dataframe. 

```{r, warning=FALSE, message=FALSE}
genus_list <- c()
for(i in unique(blood_df_slope$genus)){
  tmp <- blood_df_slope[blood_df_slope$genus==i,]
  species_num <- unique(tmp$species) %>% length()
  if(species_num>2){genus_list[i] <- as.character(tmp$genus[1])}
}
blood_df_genus <- blood_df_slope[blood_df_slope$genus %in% genus_list,]
```

```{r, echo=FALSE, fig.height=8, fig.width=8}
ggplot(blood_df_genus, aes(x=elevation, y=hb)) +
  facet_wrap(~species) +
  geom_point(pch=21,stroke=1,color="black",show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="red") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Elevation")+
  ylab("Hb")

```

Next, let's calculate the slope of haemoglobin and haematocrit—and the average slope angle for different species—using the `blood_slope()` function I've written.  

```{r,  message=FALSE, warning=FALSE}
# calculate elevational range and median
blood_df_slope$elev_range <- blood_df_slope$elev_max - blood_df_slope$elev_min

# run function
slope_df <- blood_slope(blood_df_slope)
head(slope_df)
```

We'll create a separate dataframe of variance values, using data from the 100m elevational bin with the most observations for any given species with the `blood_variance()` function: 

```{r,  message=FALSE, warning=FALSE}
# run function
variance_df <- blood_variance(blood_df_stotz_pass)
variance_df <- variance_df[complete.cases(variance_df),] 
head(variance_df)
```

Next, we'll load the Jetz supertree so we can control for phylogeny, and then subset the tree down to only those species we have slope data for: 

```{r}
supertree <-read.tree("~/Dropbox/andean_range_limits/data/birds_mcc.tre")
supertree.species <- supertree$tip.label 
slope_df$species <- sub(" ", "_", slope_df$species) 
```

There are a few taxonomic conflicts, which I'll resolve here:

```{r}
slope_df[grep("Arremon_assimilis", slope_df$species),]$species <- "Arremon_torquatus"
slope_df[grep("Myiothlypis_coronata", slope_df$species),]$species <- "Basileuterus_coronatus"
slope_df[grep("Orochelidon_murina", slope_df$species),]$species <- "Notiochelidon_murina"
slope_df[grep("Spinus_magellanicus", slope_df$species),]$species <- "Carduelis_magellanica"
slope_df[grep("Spinus_uropygialis", slope_df$species),]$species <- "Carduelis_uropygialis"
slope_df[grep("Systellura_longirostris", slope_df$species),]$species <- "Caprimulgus_longirostris"
slope_df[grep("Aglaiocercus_kingii", slope_df$species),]$species <- "Aglaiocercus_kingi"
slope_df[grep("Myiothlypis_chrysogaster", slope_df$species),]$species <- "Basileuterus_chrysogaster"
slope_df[grep("Myiothlypis_nigrocristata", slope_df$species),]$species <- "Basileuterus_nigrocristatus"
slope_df[grep("Pipraeidea_bonariensis", slope_df$species),]$species <- "Thraupis_bonariensis"
slope_df[grep("Premnornis_guttuliger", slope_df$species),]$species <- "Premnornis_guttuligera"

# prune tree
slope.tree <- keep.tip(supertree, slope_df$species)
```

And then the same thing for our variance data: 

```{r}
variance_df$species <- sub(" ", "_", variance_df$species) 
variance_df[grep("Myiothlypis_coronata", variance_df$species),]$species <- "Basileuterus_coronatus"
variance_df[grep("Myiothlypis_luteoviridis", variance_df$species),]$species <- "Basileuterus_luteoviridis"
variance_df[grep("Orochelidon_murina", variance_df$species),]$species <- "Notiochelidon_murina"
variance_df[grep("Spinus_magellanicus", variance_df$species),]$species <- "Carduelis_magellanica"
variance_df[grep("Spinus_uropygialis", variance_df$species),]$species <- "Carduelis_uropygialis"
variance_df[grep("Aglaiocercus_kingii", variance_df$species),]$species <- "Aglaiocercus_kingi"
variance_df[grep("Pipraeidea_bonariensis", variance_df$species),]$species <- "Thraupis_bonariensis"
variance_df[grep("Pheugopedius_eisenmanni", variance_df$species),]$species <- "Thryothorus_eisenmanni"
variance_df[grep("Thamnophilus_bernardi", variance_df$species),]$species <- "Sakesphorus_bernardi"
variance.tree <- keep.tip(supertree, variance_df$species)
```

Now, we'll attempt to fit basic phylogenetic least squares (PGLS) models to our data using Liam Revell's phytools. For now, we're going to ignore possible sex-based confounds, and analyze only the subset of variance estimates we have matching slope estimates for. Specifically, we're going to fit models attemping to predict the rate of change  across elevation in Hb, Hct, and MCHC using a species elevational range breadth, median elevational range, and mass as predictors, while weighting the dependent variable by the standard error of the linear regression that generated it, and controlling for phylogeny. 

```{r, message=FALSE, warning=FALSE}
# scale variables to be same order of magnitude
slope_df$mass <- slope_df$mass/1000
slope_df$elev_range <- slope_df$elev_range/1000000
slope_df$median_elevation <- slope_df$median_elevation/1000000
slope_df$slope_hct <- slope_df$slope_hct*10

# assign rownames
species1 <- as.vector(as.character(slope_df$species))
rownames(slope_df) <- species1

# get SE of hb measurements
SE1 <-setNames(slope_df$error_hb, slope.tree$tip.label)

# fit model, hb
fit_hb <- pgls.SEy(slope_hb ~ elev_range + median_elevation + mass, 
                   data=slope_df, se=SE1, tree=slope.tree, method="ML")
fit_hb.tidy <- broom.mixed:::tidy.gls(fit_hb)
fit_hb.tidy

# get SE of hct measurements
SE2 <-setNames(slope_df$error_hct, slope.tree$tip.label)

# fit model, hct
fit_hct <- pgls.SEy(slope_hct ~ elev_range + median_elevation + mass, 
                    data=slope_df, se=SE2, tree=slope.tree, method="ML")
fit_hct.tidy <- broom.mixed:::tidy.gls(fit_hct)
fit_hct.tidy

# get SE of mchc measurements
SE3 <-setNames(slope_df$error_mchc, slope.tree$tip.label)

# fit model, mchc
fit_mchc <- pgls.SEy(slope_mchc ~ elev_range + median_elevation + mass, 
                     data=slope_df, se=SE3, tree=slope.tree, method="ML")
fit_mchc.tidy <- broom.mixed:::tidy.gls(fit_mchc)
fit_mchc.tidy
```

I printed out tables of coefficients there, but since that's a lot to take in, let's visualize these results:

```{r, echo=FALSE, message=FALSE, error=FALSE, fig.height=6, fig.width=4}
p1 <- ggplot(fit_hb.tidy, aes(x=estimate, y=term, color=term)) + 
  theme_bw() +
  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.1) +
  geom_line() +
  geom_vline(xintercept = 0, linetype="dashed") +
  geom_point(pch=1,size=3) +
  geom_text(data=subset(fit_hb.tidy, fit_hb.tidy$term=="elev_range"), y = -0.75, label = "*") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("(Intercept)","elev_range","median_elevation","mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Mass")) +
  scale_color_manual(values=c("black","black","black","red")) +
  theme(legend.position = "none") +
  ggtitle("Hemoglobin")

p2 <- ggplot(fit_hct.tidy, aes(x=estimate, y=term, color=term)) + 
  theme_bw() +
  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.1) +
  geom_line() +
  geom_vline(xintercept = 0, linetype="dashed") +
  geom_point(pch=1,size=3) +
  geom_text(data=subset(fit_hb.tidy, fit_hb.tidy$term=="elev_range"), y = -0.75, label = "*") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("(Intercept)","elev_range","median_elevation","mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Mass")) +
  scale_color_manual(values=c("black","red","black","black")) +
  theme(legend.position = "none") +
  ggtitle("Hematocrit")

p3 <- ggplot(fit_mchc.tidy, aes(x=estimate, y=term, color=term)) + 
  theme_bw() +
  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.1) +
  geom_line() +
  geom_vline(xintercept = 0, linetype="dashed") +
  geom_point(pch=1,size=3) +
  geom_text(data=subset(fit_hb.tidy, fit_hb.tidy$term=="elev_range"), y = -0.75, label = "*") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("(Intercept)","elev_range","median_elevation","mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Mass")) +
  scale_color_manual(values=c("black","red","black","red")) +
  theme(legend.position = "none") +
  ggtitle("MCHC")

plot_grid(p1,p2,p3,nrow=3)
```

TL;DR: Median range elevation is a significant positive predictor of the slope of Hb and MCHC; elevational range breadth is a significant negative predictor of Hct and significant positive predictor of MCHC.  

Next, let's run models attempting to describe variance in these blood parameters. This time, we're going to use the number of unique elevations we have data for as our weighting criterion: 

```{r, message=FALSE, warning=FALSE}
# assign rownames
species2 <- as.vector(as.character(variance_df$species))
rownames(variance_df) <- species2

# get variances in correct order of magnitude; Hct fine
variance_df$variance_hb <- variance_df$variance_hb/1000
variance_df$variance_mchc <- variance_df$variance_mchc/1000
variance_df$mass <- variance_df$mass/1000
variance_df$elev_range <- variance_df$elev_range/1000000
variance_df$median_elevation <- variance_df$median_elevation/1000000
variance_df$range_position <- variance_df$range_position/100
variance_df$edge_distance <- variance_df$edge_distance/100

# get SE of hb measurements
SE_elev <-setNames(variance_df$unique_elevations, variance.tree$tip.label)

# fit model, hb
fit_vhb <- pgls.SEy(variance_hb ~ elev_range + median_elevation + range_position + edge_distance + mass, data=variance_df, se=SE_elev, tree=variance.tree)
fit_vhb.tidy <- broom.mixed:::tidy.gls(fit_vhb)
fit_vhb.tidy

# fit model, hct
fit_vhct <- pgls.SEy(variance_hct ~ elev_range + median_elevation + range_position + edge_distance + mass, data=variance_df, se=SE_elev, tree=variance.tree)
fit_vhct.tidy <- broom.mixed:::tidy.gls(fit_vhct)
fit_vhct.tidy

# fit model, hct
fit_vmchc <- pgls.SEy(variance_mchc ~ elev_range + median_elevation + range_position + edge_distance + mass, data=variance_df, se=SE_elev, tree=variance.tree)
fit_vmchc.tidy <- broom.mixed:::tidy.gls(fit_vmchc)
fit_vmchc.tidy
```

```{r, echo=FALSE, message=FALSE, error=FALSE, fig.height=8, fig.width=4}
g1 <- ggplot(fit_vhb.tidy, aes(x=estimate, y=term, color=term)) + 
  theme_bw() +
  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.1) +
  geom_line() +
  geom_vline(xintercept = 0, linetype="dashed") +
  geom_point(pch=1,size=3) +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("(Intercept)","elev_range","median_elevation","range_position","edge_distance","mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Rel. Range Position", "Dist.from Edge", "Mass")) +
  scale_color_manual(values=c("black","black","red","black","red","black")) +
  theme(legend.position = "none") +
  ggtitle("Hemoglobin")

g2 <- ggplot(fit_vhct.tidy, aes(x=estimate, y=term, color=term)) + 
  theme_bw() +
  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.1) +
  geom_line() +
  geom_vline(xintercept = 0, linetype="dashed") +
  geom_point(pch=1,size=3) +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("(Intercept)","elev_range","median_elevation","range_position","edge_distance","mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Rel. Range Position", "Dist.from Edge", "Mass")) +
  scale_color_manual(values=c("red","black","black","red","red","black")) +
  theme(legend.position = "none") +
  ggtitle("Hematocrit")

g3 <- ggplot(fit_vmchc.tidy, aes(x=estimate, y=term, color=term)) + 
  theme_bw() +
  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.1) +
  geom_line() +
  geom_vline(xintercept = 0, linetype="dashed") +
  geom_point(pch=1,size=3) +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("(Intercept)","elev_range","median_elevation","range_position","edge_distance","mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Rel. Range Position", "Dist.from Edge", "Mass")) +
  scale_color_manual(values=c("black","black","black","black","black","black")) +
  theme(legend.position = "none") +
  ggtitle("MCHC")

plot_grid(g1,g2,g3,nrow=3)
```

Median range elevation is a significant negative predictor of variance in Hb and Hct; Elevational range breadth is a significant positive predictor of variance in Hb; mass is a significant negative predictor of variance in Hct. There are no good predictors of MCHC. 
