---
title: "Andean bird blood data exploration"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Introduction

What constrains elevational range limits in the absence of an ecotone or obvious biotic constraints? One *abiotic* factor that falls under what Terborgh& Weske (1975) called constraints that vary "continuously and in parallel with the elevational gradient" is the partial pressure of oxygen (PO2), which declines roughly linearly with altitude and is an strong selective pressure.

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.height=4,fig.width=8}
# libraries
library(ggplot2)
library(cowplot)
library(tidyverse, quietly = TRUE)

# load functions script
source("~/Dropbox/andean_range_limits/scripts/00_functions.R")

# calculate water vapor pressure based on temperature and humidity
wvp <- water_vapor_pressure(temp_celsius = 15, humidity = 20)

# assign coefficients for formulae
sea_level_pressure <- 760 # in mmHg
mass <- 0.0289644 # molar mass of gas in kg/mol
gravity <- 9.81 # acceleration due to gravity in m/s2
gas_constant <- 8.3145 #J/molK
temp_kelvin <- 15 + 273.15 # assuming 15C here
mbar_conversion <- 1.33322 # convert mmHg to mbar
o2 <- 0.2095 # proportion o2 in atmosphere
max_o2 <- ((sea_level_pressure*exp(-(mass*gravity)/(gas_constant*temp_kelvin)*0)*mbar_conversion)-wvp)*o2

# barometric formula
p <- function(x) sea_level_pressure *exp(-(mass*gravity)/(gas_constant*temp_kelvin)*x)*mbar_conversion
o <- function(x) ((sea_level_pressure*exp(-(mass*gravity)/(gas_constant*temp_kelvin)*x)*mbar_conversion)-wvp)*o2
po2 <-function(x) (((sea_level_pressure*exp(-(mass*gravity)/(gas_constant*temp_kelvin)*x)*mbar_conversion)-wvp)*o2/max_o2)*100

n1 <- ggplot(data = data.frame(x = 0), mapping = aes(x = x)) +
  theme_bw() +
  stat_function(fun = p, aes(linetype="Atmospheric Pressure")) +
  stat_function(fun = o, aes(linetype="PO2")) +
  scale_linetype_discrete(labels=c("Atm", 
                                   expression(PO[2]))) +
  theme(panel.grid = element_blank()) +
  xlim(0,8000) +
  #ylim(0,1200) +
  xlab("Elevation (m)") +
  ylab("Millibars") +
  labs(linetype=element_blank()) +
  theme(legend.position = c(0.8, 0.9))

n2 <- ggplot(data = data.frame(x = 0), mapping = aes(x = x)) +
  theme_bw() +
  stat_function(fun = po2) +
  scale_linetype_discrete(guide=FALSE) +
  theme(panel.grid = element_blank()) +
  xlim(0,9500) +
  ylim(0,100) +
  geom_vline(xintercept = 1619, size=3, alpha=0.3) +
  geom_text(aes(x=1319, label="Albuquerque, NM: 82%", y=20), angle=90, size=3) +
  geom_vline(xintercept = 3982, size=3, alpha=0.2) +
  geom_text(aes(x=3682, label="Mt. Wheeler, NM: 62%", y=20), angle=90, size=3) +
  geom_vline(xintercept = 6768, size=3, alpha=0.1) +
  geom_text(aes(x=6468, label="Huascarán, Peru: 44%", y=20), angle=90, size=3) +
  geom_text(aes(x=8300, label="15°C, 20% humidity", y=100,), size=3) +
  xlab("Elevation (m)") +
  ylab(expression(paste("% sea level ", PO[2]))) +
  labs(linetype=element_blank()) +
  theme(legend.position = c(0.8, 0.9))

plot_grid(n1, n2)
```

In this analysis, we're using a large dataset of blood trait values (total blood hemoglobin concentration, haematocrit, or the volume percentage of red blood cells in blood, and MCHC, or mean cellular hemoglobin concentration) to try and understand a little bit better why tropical birds have such narrow elevational ranges. How narrow, you ask? Here's a visualization of the distribution of elevational range breadth using data from the 3,752 neotropical bird  species in [Parker et al. 1996](https://www.press.uchicago.edu/ucp/books/book/chicago/E/bo3618705.html) (what Chris calls the "Stotz" data)".

```{r message=FALSE, warning=FALSE}
# load libraries
library(tidyverse, quietly = TRUE)
library(magrittr)
library(ape)
library(phangorn)
library(nlme)
library(phytools)
library(cowplot)
library(mapdata)

# load functions script
source("~/Dropbox/andean_range_limits/scripts/00_functions.R")

# load stotz data
stotz <- read.csv("~/Dropbox/andean_range_limits/data/stotz_elevation_data.csv")
stotz <- cbind.data.frame(stotz$GENUS, stotz$SPECIES, 
                          stotz$MIN, stotz$MAX, stotz$MIDPT.ELEV)
colnames(stotz) <- c("genus","species","elev_min","elev_max","elev_midpt")
stotz$elev_range <- stotz$elev_max - stotz$elev_min
stotz_mod <- stotz[stotz$elev_range>0,]
```
```{r, message=FALSE, warning=FALSE, fig.height=4, fig.width=7}
ggplot(stotz_mod, aes(x=elev_range)) +
  geom_histogram(binwidth = 100, color="black",fill="gray70") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        panel.grid = element_blank()) +
  xlab("elevational range breadth")  +
  geom_vline(xintercept = median(stotz$elev_range, na.rm=TRUE),
             linetype="dashed",size=1.5, color="red")

```

Quite narrow, with strong left skew and a median elevational range breadth of 1100 m.

More specifically, we're interested in the following questions: 

1) Is a species' elevational range breadth associated the rate of change (slope) of its blood trait values a cross elevation?

2) Is a species' elevational range breadth associated the total variance of its blood trait values?

3) Is the median elevation of a species' range associated with either of these variables?

To begin, we're going to load our data, take a look at it, and make some filtering choices.  

### Cleaning

```{r, message=FALSE, warning=FALSE}
# load data
blood_df <- read.csv("~/Dropbox/andean_range_limits/data/blood_data.csv", 
                     stringsAsFactors = FALSE)

# subset columns of interest
blood_df <- cbind.data.frame(blood_df$Scientific.name, 
                             blood_df$Elevation, 
                             blood_df$Bursa,
                             blood_df$Mass.for.analyses, 
                             blood_df$tHbcorr,
                             blood_df$HctBestEstimate,
                             blood_df$Latitude..degrees.S, 
                             blood_df$Latitude.minutes,
                             blood_df$Longitude.degrees.W, 
                             blood_df$Longitude.minutes,
                             blood_df$Sex)

colnames(blood_df) <- c("species","elevation","bursa","mass","hb","hct", "lat_degrees",
                        "lat_minutes", "long_degrees", "long_minutes", "sex")

# fix longitude minutes error
blood_df$long_minutes <- blood_df$long_minutes %>% as.character() %>% as.numeric()

# fix lat long issue
blood_df$lat <- convert_lat(blood_df)*-1
blood_df$long <- convert_long(blood_df)*-1

# drop sites without locality data 
blood_df <- blood_df[!is.na(blood_df$long),]
blood_df <- blood_df[!is.na(blood_df$lat),]

# drop sites beyond plausible limits of sampling
blood_df <- blood_df[blood_df$lat>(-19),]
blood_df <- blood_df[blood_df$long<(-67),]

# drop old lat long columns
blood_df <- blood_df[,-c(7:10)]

# factor to character nonsense
blood_df$species <- as.character(blood_df$species)
blood_df$elevation <- as.numeric(as.character(blood_df$elevation))
blood_df$hb <-as.numeric(as.character(blood_df$hb))

# drop all missing records (elevation, haemoglobin, haematocrit)
blood_df <- blood_df[!is.na(blood_df$elevation),]
blood_df <- blood_df[!is.na(blood_df$hb),]
blood_df <- blood_df[!is.na(blood_df$hct),]
```

Before we start, where do these records come from, and how are they distributed across elevation?

```{r, echo=FALSE, fig.height=4, fig.width=8}
coast_map <- fortify(map("worldHires", fill=TRUE, plot=FALSE))
c <- ggplot() + coord_map() +
  theme_bw() +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  #geom_map(data=coast_map, map=coast_map, aes(x=long, y=lat, map_id=region), 
  #         fill="white", color="black") +
  geom_map(data=data.frame(region="Peru"), map=coast_map,
                    aes(map_id=region), fill="gray100", col="gray0") + 
  xlim(-82,-68) + 
  ylim(-19,0.5) +
  #geom_point(data=df,aes(x=long, y=lat,fill=elev), colour="black",pch=21,alpha=0.3,size = 0.5) + 
  #scale_fill_gradient(low = "white", high = "black") +
  #xlab("longitude") +
  #ylab("latitude") +
  stat_bin2d(data=blood_df, aes(x=long, y=lat,fill = ..count..), color="black", binwidth = c(0.5,0.5)) +
  scale_fill_gradient(low = "white", high = "black") #name = element_blank())

d <- ggplot(blood_df, aes(x=elevation)) + geom_histogram(binwidth = 100, color="black",fill="gray70") +
  theme_bw() +
  theme(axis.title.y = element_blank()) +
  xlab("elevation (m)")

plot_grid(c, d)
```

Now let's take a look at the head of the dataframe: 

```{r, message=FALSE, warning=FALSE}
# simplified column names
head(blood_df)
```

As you can see, we have columns for species, elevation, presence or absence of a bursa, mass, haemoglobin, haematocrit, collection site longitude and latitude, and sex. As we're also interested in MCHC, let's add a column for that now, using the formula from Campbell and Ellis (thanks, Jessie!)

```{r}
blood_df <- blood_df %>% mutate(hct_percent = hct*100)
blood_df <- blood_df %>% mutate(MCHC_calculated = (hb/hct_percent)*100) # Calculated MCHC
```

Next, let's do some basic filtering, and drop extreme blood parameter values. 

We'll first look at the distribution of blood trait values across all species, using a tidyverse-friendly version of the dataframe:

```{r, message=FALSE, warning=FALSE}
blood_tidy <- blood_df %>% pivot_longer(c(hb, hct, MCHC_calculated), 
                                        names_to = "key", values_to = "value")
```
```{r,echo=FALSE}
s1 <- ggplot(blood_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_x") +
  geom_histogram() +
  theme(panel.grid = element_blank())

s2 <- ggplot(blood_tidy, aes(sample=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_y") +
  stat_qq() +
  theme(panel.grid = element_blank())

plot_grid(s1,s2,nrow=2)
```

Using these plots to inform our cutoffs, let's drop outliers / somewhat normalize distributions:

```{r,  message=FALSE, warning=FALSE}
blood_df_sub <- blood_df[which(blood_df$hb >= 8 &  blood_df$hb <= 25),]
blood_df_sub <- blood_df_sub[which(blood_df_sub$hct >= 0.3 &  
                                     blood_df_sub$hct <= 0.8),]
blood_df_sub <- blood_df_sub[which(blood_df_sub$MCHC_calculated >= 22 
                                   & blood_df_sub$MCHC <= 42),] 
blood_tidy <- blood_df_sub %>% pivot_longer(c(hb, hct, MCHC_calculated), 
                                            names_to = "key", values_to = "value")

```
```{r,echo=FALSE}
s1 <- ggplot(blood_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_x") +
  geom_histogram() +
  theme(panel.grid = element_blank())

s2 <- ggplot(blood_tidy, aes(sample=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_y") +
  stat_qq() +
  theme(panel.grid = element_blank())

plot_grid(s1,s2,nrow=2)
```

Looking much better. We'll then drop species with fewer than 8 records: 

```{r, message=FALSE, warning=FALSE}
sp_list <- c()
for(i in blood_df_sub$species){
  tmp <- blood_df_sub[blood_df_sub$species==i,]
  records <- nrow(tmp)
  if(records > 7){sp_list[i] <- as.character(tmp$species[1])}
}
sp_list <- as.vector(sp_list)

# subset down to "good" species
blood_df_sub <- blood_df_sub[blood_df_sub$species %in% sp_list,]

length(unique(blood_df$species)) # number of unique species before filtering
nrow(blood_df) # number of unique records before filtering
length(unique(blood_df_sub$species)) # number of unique species after filtering
nrow(blood_df_sub) # number of unique records after filtering
```

We'll now merge these data with the Stotz data. We're using the parameter `all.x=TRUE`, which just means we aren't going to drop blood data if there's not a taxonomy match with the Stotz table. 

```{r,  message=FALSE, warning=FALSE}
stotz$binomial <- paste0(stotz$genus, " ", stotz$species) # create single col for sp.
blood_df_stotz <- merge(blood_df_sub, stotz, by.x = "species", by.y = "binomial", 
                        all.x=TRUE)
head(blood_df_stotz)
```

Which species failed to pick up elevational range data?  

```{r,  message=FALSE, warning=FALSE}
blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique() %>% length() 
```

Bummer. Let's take a look them:   
 
```{r,  message=FALSE, warning=FALSE}
missing <- blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
print(missing)
```

All can be explained by taxonomic changes and / or typos. I've gone directly to a copy of the spreadsheet and made the taxonomy of the Stotz data match to avoid errors from manually entering elevations. We'll now merge again, the revised data: 

```{r}
stotz_rev <- read.csv("~/Dropbox/andean_range_limits/data/stotz_elevation_data_rev.csv")
stotz_rev <- cbind.data.frame(stotz_rev$GENUS, stotz_rev$SPECIES, 
                          stotz_rev$MIN, stotz_rev$MAX, stotz_rev$MIDPT.ELEV)
colnames(stotz_rev) <- c("genus","species","elev_min","elev_max","elev_midpt")
stotz_rev$binomial <- paste0(stotz_rev$genus, " ", stotz_rev$species)
blood_df_stotz <- merge(blood_df_sub, stotz_rev, by.x = "species", by.y = "binomial", 
                        all.x=TRUE)
```

Anything still missing?

```{r,  message=FALSE, warning=FALSE}
missing <- blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
length(missing)
```

Yep—let's see  what it is. 

```{r}
blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
```

Unidentified siskins—we'll drop them.

```{r}
blood_df_stotz <- blood_df_stotz[!blood_df_stotz$species=="Spinus sp.",]
```

We'll next apply a filter to drop probable outliers that could have a disproportionate influence on slope estimation, using my custom `outliers_cooks()` function: points with Cook's D of 4/n, or with a Cook's D of 3.5/n if a bursa is present. 

```{r,  message=FALSE, warning=FALSE}
pass_hb <- outliers_cooks(blood_df_stotz, "hb", 4, 3.5)
pass_hct <- outliers_cooks(blood_df_stotz, "hct", 4, 3.5)
pass_mchc <- outliers_cooks(blood_df_stotz, "MCHC_calculated", 4, 3.5)
blood_df_stotz_pass <- intersect(pass_hb, pass_hct, pass_mchc) # get overlapping spp. set
length(unique(blood_df_stotz_pass$species)) # number of unique species
nrow(blood_df_stotz_pass) # retained records
```

For calculating variance down the road, we also need to records based on their relative position in a species' elevational range.

```{r,warning=FALSE}
vardf <- list()
for(i in unique(blood_df_stotz_pass$species)){
  tmp <- blood_df_stotz_pass[blood_df_stotz_pass$species==i,]
  if(tmp$elev_max > max(tmp$elevation)){elev_max <- unique(tmp$elev_max)}
  if(tmp$elev_max < max(tmp$elevation)){elev_max <- max(tmp$elevation)}
  if(tmp$elev_min < min(tmp$elevation)){elev_min <- unique(tmp$elev_min)}
  if(tmp$elev_min > min(tmp$elevation)){elev_min <- min(tmp$elevation)}
  elev_range <- elev_max - elev_min
  tmp$range_position <- 1-((elev_max-tmp$elevation)/elev_range)
  tmp$edge_distance <- 0.5-abs(tmp$range_position-0.5)
  tmp$elev_range <- elev_range
  tmp$elev_min <- elev_min
  tmp$elev_max <- elev_max
  bin_number <- elev_range %/% 100
  tmp$binID <- cut(tmp$elevation, bin_number)
  vardf[[i]] <- tmp
}
blood_df_stotz_pass <- do.call(rbind, vardf)
```

We're now going to apply a final set of filters to the data (using the function `outliers_limits()`), removing all species with fewer than 2 unique elevational records at least 150 m apart, and fewer than 2 elevational records in the first and last quartile of their range. (This will create the dataframe we'll use for our analysis of the slope of blood parameters—for variance, we'll begin working with a separate dataframe, as we aren't concered with how much of the range these data span.)

```{r,  message=FALSE, warning=FALSE}
blood_df_slope <- outliers_limits(blood_df_stotz_pass, min_sample=2, min_limit=2, 200)
length(unique(blood_df_slope$species)) # number of unique species
nrow(blood_df_slope) # number of unique records
```

Let's visualize these slope data (printing large .pdfs elsewhere):  

```{r, eval=FALSE}
multispecies_hb <- ggplot(blood_df_slope, aes(x=elevation, y=hb)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("hb")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_hb.pdf",width=24,height=20)
multispecies_hb
dev.off()

multispecies_hct <- ggplot(blood_df_slope, aes(x=elevation, y=hct)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("hct")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_hct.pdf",width=24,height=20)
multispecies_hct
dev.off()

multispecies_mchc <- ggplot(blood_df_slope, aes(x=elevation, y=MCHC_calculated)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("mchc")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_mchc.pdf",width=24,height=20)
multispecies_mchc
dev.off()
```

Let's take a quick look at patterns in genera with more than two species. First, we'll subset the dataframe. 

```{r, warning=FALSE, message=FALSE}
genus_list <- c()
for(i in unique(blood_df_slope$genus)){
  tmp <- blood_df_slope[blood_df_slope$genus==i,]
  species_num <- unique(tmp$species) %>% length()
  if(species_num>2){genus_list[i] <- as.character(tmp$genus[1])}
}
blood_df_genus <- blood_df_slope[blood_df_slope$genus %in% genus_list,]
```

```{r, echo=FALSE, fig.height=8, fig.width=8}
ggplot(blood_df_genus, aes(x=elevation, y=hb)) +
  facet_wrap(~species) +
  geom_point(pch=21,stroke=1,color="black",show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="red") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Elevation")+
  ylab("Hb")

```

Next, let's calculate the slope of hemoglobin and hematocrit—and the average slope angle for different species—using the `blood_slope()` function I've written.  

```{r,  message=FALSE, warning=FALSE}
# calculate elevational range and sampling range
blood_df_slope$elev_range <- blood_df_slope$elev_max - blood_df_slope$elev_min

# run function
slope_df <- blood_slope(blood_df_slope)
head(slope_df)
```

We'll create a separate dataframe of variance values, using data from the 100m elevational bin with the most observations for any given species with the `blood_variance()` function: 

```{r,  message=FALSE, warning=FALSE}
# run function
variance_df <- blood_variance(blood_df_stotz_pass, 5)
variance_df <- variance_df[complete.cases(variance_df),] 
head(variance_df)
nrow(variance_df)
length(unique(variance_df$species))
```

Next, we'll load the Jetz supertree so we can control for phylogeny, and then subset the tree down to only those species we have slope data for: 

```{r}
supertree <-read.tree("~/Dropbox/andean_range_limits/data/birds_mcc.tre")
supertree.species <- supertree$tip.label 
slope_df$species <- sub(" ", "_", slope_df$species) 
```

There are a few taxonomic conflicts, which I'll resolve here:

```{r}
slope_df[grep("Arremon_assimilis", slope_df$species),]$species <- "Arremon_torquatus"
slope_df[grep("Myiothlypis_coronata", slope_df$species),]$species <- "Basileuterus_coronatus"
#slope_df[grep("Myiothlypis_luteoviridis", slope_df$species),]$species <- "Basileuterus_luteoviridis"
slope_df[grep("Orochelidon_murina", slope_df$species),]$species <- "Notiochelidon_murina"
slope_df[grep("Spinus_magellanicus", slope_df$species),]$species <- "Carduelis_magellanica"
slope_df[grep("Spinus_uropygialis", slope_df$species),]$species <- "Carduelis_uropygialis"
# slope_df[grep("Spinus_crassirostris", slope_df$species),]$species <- "Carduelis_crassirostris"
slope_df[grep("Systellura_longirostris", slope_df$species),]$species <- "Caprimulgus_longirostris"
slope_df[grep("Aglaiocercus_kingii", slope_df$species),]$species <- "Aglaiocercus_kingi"
slope_df[grep("Myiothlypis_chrysogaster", slope_df$species),]$species <- "Basileuterus_chrysogaster"
slope_df[grep("Myiothlypis_nigrocristata", slope_df$species),]$species <- "Basileuterus_nigrocristatus"
slope_df[grep("Pipraeidea_bonariensis", slope_df$species),]$species <- "Thraupis_bonariensis"
slope_df[grep("Premnornis_guttuliger", slope_df$species),]$species <- "Premnornis_guttuligera"
# slope_df[grep("Ceratopipra_chloromeros", slope_df$species),]$species <- "Pipra_chloromeros"
# slope_df[grep("Chloropipo_unicolor", slope_df$species),]$species <- "Xenopipo_unicolor"
slope_df[grep("Thamnophilus_bernardi", slope_df$species),]$species <- "Sakesphorus_bernardi"
# slope_df[grep("Cercomacroides_serva", slope_df$species),]$species <- "Cercomacra_serva"

# prune tree
slope.tree <- keep.tip(supertree, slope_df$species)

# write to files
write.csv(slope_df, file="~/Dropbox/andean_range_limits/data/blood_slopes.csv")
write.tree(slope.tree, file="~/Dropbox/andean_range_limits/data/blood_slope.tre")
```

And then the same thing for our variance data: 

```{r}
variance_df$species <- sub(" ", "_", variance_df$species) 
variance_df[grep("Myiothlypis_coronata", variance_df$species),]$species <- "Basileuterus_coronatus"
variance_df[grep("Myiothlypis_luteoviridis", variance_df$species),]$species <- "Basileuterus_luteoviridis"
# variance_df[grep("Myiothlypis_nigrocristata", variance_df$species),]$species <- "Basileuterus_nigrocristatus"
# variance_df[grep("Orochelidon_murina", variance_df$species),]$species <- "Notiochelidon_murina"
variance_df[grep("Spinus_magellanicus", variance_df$species),]$species <- "Carduelis_magellanica"
variance_df[grep("Spinus_uropygialis", variance_df$species),]$species <- "Carduelis_uropygialis"
variance_df[grep("Aglaiocercus_kingii", variance_df$species),]$species <- "Aglaiocercus_kingi"
variance_df[grep("Pipraeidea_bonariensis", variance_df$species),]$species <- "Thraupis_bonariensis"
variance_df[grep("Pheugopedius_eisenmanni", variance_df$species),]$species <- "Thryothorus_eisenmanni"
variance_df[grep("Thamnophilus_bernardi", variance_df$species),]$species <- "Sakesphorus_bernardi"
# variance_df[grep("Isleria_hauxwelli", variance_df$species),]$species <- "Myrmotherula_hauxwelli"
#variance_df[grep("Systellura_longirostris", variance_df$species),]$species <- "Caprimulgus_longirostris"


# prune tree
variance.tree <- keep.tip(supertree, variance_df$species)

# write to files
write.csv(variance_df, file="~/Dropbox/andean_range_limits/data/blood_variances.csv")
write.tree(variance.tree, file="~/Dropbox/andean_range_limits/data/blood_variances.tre")
```

Before moving on to model fitting, let's visualize the distribution of blood parameter slopes and variances—a key descriptive contribution of the study:

```{r}
# tidy dataframe
slope_tidy <- slope_df %>% pivot_longer(c(slope_hb, slope_hct, slope_mchc), 
                                         names_to = "key", values_to = "value")
```
```{r, echo=FALSE}

# change facet labels
slope_tidy$key <- factor(slope_tidy$key)
levels(slope_tidy$key) <- c("Hb", "Hct", "MCHC")

# estimate medians
median_hb <- slope_tidy[slope_tidy$key=="Hb",]$value %>% median()
median_hct <- slope_tidy[slope_tidy$key=="Hct",]$value %>% median()
median_mchc <- slope_tidy[slope_tidy$key=="MCHC",]$value %>% median()


# plot
ggplot(slope_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_x") +
  geom_histogram(bins=50, fill=NA, color="black") +
  geom_vline(data=filter(slope_tidy, key=="Hb"), aes(xintercept=median_hb), colour="red",
             linetype="dashed") + 
  geom_vline(data=filter(slope_tidy, key=="Hct"), aes(xintercept=median_hct), colour="red",
             linetype="dashed") + 
    geom_vline(data=filter(slope_tidy, key=="MCHC"), aes(xintercept=median_mchc), colour="red",
             linetype="dashed") + 
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Slope") +
  ylab("Count")

```

This shows us the median slope value for change in Hb or Hct is greater than 0, but is difficult to tell for MCHC. Let's test this formally: 

```{r}
# shapiro test to see if t-test is appropriate (e.g. data are normally distributed)
shapiro.test(slope_df$slope_hb) # W = 0.9478, p-value = 0.0003168
shapiro.test(slope_df$slope_hct) # W = 0.9031, p-value = 8.109e-07
shapiro.test(slope_df$slope_mchc) # W = 0.83395, p-value = 1.011e-09

# all fail, so wilcox test better
wilcox.test(slope_df$slope_hb) # V = 4034, p-value = 0.001736
wilcox.test(slope_df$slope_hct) # V = 4143, p-value = 0.0005369
wilcox.test(slope_df$slope_mchc) # V = 3205, p-value = 0.5314
```

As expected, the slope values for Hb and Hct are significantly greater than 0, but those for MCHC are not. What's going on with variance?

```{r}
# tidy dataframe
variance_tidy <- variance_df %>% pivot_longer(c(variance_hb, variance_hct, variance_mchc), 
                                         names_to = "key", values_to = "value")
```

```{r, echo=FALSE}
# change facet labels
variance_tidy$key <- factor(variance_tidy$key)
levels(variance_tidy$key) <- c("Hb", "Hct", "MCHC")

# estimate medians
median_hb <- variance_tidy[variance_tidy$key=="Hb",]$value %>% median()
median_hct <- variance_tidy[variance_tidy$key=="Hct",]$value %>% median()
median_mchc <- variance_tidy[variance_tidy$key=="MCHC",]$value %>% median()

# plot
ggplot(variance_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key) +
  geom_histogram(bins=50, fill=NA, color="black") +
  geom_vline(data=filter(variance_tidy, key=="Hb"), aes(xintercept=median_hb), colour="red",
             linetype="dashed") + 
  geom_vline(data=filter(variance_tidy, key=="Hct"), aes(xintercept=median_hct), colour="red",
             linetype="dashed") + 
    geom_vline(data=filter(variance_tidy, key=="MCHC"), aes(xintercept=median_mchc), colour="red",
             linetype="dashed") + 
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Variance") +
  ylab("Count")
```

Looks like the variance of the coefficient of variation (lol) is normalish, with one fat tail, and left-skewed.

And let's also make scatter plots of everything I find interesting:  

```{r, echo=FALSE, fig.height=9,fig.width=7}
a <- ggplot(slope_tidy, aes(x=elev_range, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
  geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  ylab("Slope") +
  xlab("Elevational Range Breadth")

b <- ggplot(slope_tidy, aes(x=median_elevation, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
  geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  ylab("Slope") +
  xlab("Median Range Elevation")

c <- ggplot(variance_tidy, aes(x=edge_distance, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
 # geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
    ylab("Variance") +
  xlab("Edge Distance")

d <- ggplot(variance_tidy, aes(x=bin_elevation, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
  # geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
    ylab("Variance") +
  xlab("Bin Elevation")

plot_grid(a, b, c, d, labels="AUTO", nrow=4)

```

Interesting, some vague hints of patterns—but what does it mean? 

To tackle that' we're going to build generative Bayesian models using Stan implemented in the R package brms. Specifically, we're going to test the following (generalized) hypotheses:

#### Slope  

$H_{0}$: The slope of change in blood parameter values is unrelated to predictors (elevational range breadth, median range elevation, sampling range, mass) and best explained by phylogeny alone

$H_{1}$: The slope of change in blood parameter values is best explained by all predictors and phylogeny 

$H2$: The slope of change in blood parameter values is best explained by a subset of predictors and phylogeny  

#### Variance

$H_{0}$: Variance in a given 100 m elevation bin is unrelated to predictors (distance from range edge, relative position in range, median bin elevation) and best explained by phylogeny alone

$H_{1}$: Variance in a given 100 m elevation bin is best explained by phylogeny alone

$H_{2}$: Variance in a given 100 m elevation bin is explained by a subset of predictors and phylogeny  

For each of these hypotheses and each blood trait, we built a corresponding model in `brms()`. For example, the full set of models predicting the rate of change in total blood hemoglobin concentration per unit elevation is as follows:

```{r, eval=FALSE}
### slope models, hemoglobin

# full model
slope_full_hb <- brm(
  formula = bf(slope_hb  ~ 1 + elev_range + sampling_range  + mass + median_elevation +
                 (1 | gr(phylo, cov=A))),
  data = slope_df, 
  family = student(), 
  data2 = list(A = A),
  iter = 10000,
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  prior = c(
    prior(normal(0, 10), "b", coef="elev_range"),
    prior(normal(0, 10), "b", coef="sampling_range"),
    prior(normal(0, 10), "b", coef="mass"),
    prior(normal(0, 10), "b", coef="median_elevation"),
    prior(normal(0, 10), "Intercept"),
    prior(student_t(3, 0, 2), "sd"),
    prior(student_t(3, 0, 2), "sigma")
  )
)

# simple model
slope_hb <- brm(
  formula = bf(slope_hb  ~ 1 + elev_range + median_elevation + (1 | gr(phylo, cov=A))),
  data = slope_df, 
  family = student(), 
  data2 = list(A = A),
  iter = 10000,
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  prior = c(
    prior(normal(0, 10), "b", coef="elev_range"),
    prior(normal(0, 10), "b", coef="median_elevation"),
    prior(normal(0, 10), "Intercept"),
    prior(student_t(3, 0, 2), "sd"),
    prior(student_t(3, 0, 2), "sigma")
  )
)

# null model, phylogeny only 
slope_null_hb <- brm(
  slope_hb  ~ 0 + (1 | gr(phylo, cov=A)),
  data = slope_df, 
  family = student(), 
  data2 = list(A = A),
  iter = 10000,
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  prior = c(
    prior(student_t(3, 0, 2), "sd"),
    prior(student_t(3, 0, 2), "sigma")
  )
)
```

Here, we model the response variable (slope) using a Student's-t distribution, to account for heavy tails (more outliers than expected under strict neutrality). We also invoke regularizing priors, to keep the model from getting TOO excited by our data, though undocumented experimentation suggests this isn't really necessary. Importantly, the second model includes *only those predictors with a 95% percent credible interval for* $\beta$ *that doesn't overlap 0.* If no predictors met this criterion, we compared the full model ($H_{1}$) with the corresponding null model ($H_{0}$) alone. We evaluated convergence by examining traceplots, checking ESS values, and making sure $\hat{R}$ values were equal to 1.00. We evaluated model fit using posterior predictive checks for the overall distribution, and the `loo()` function, making sure there weren't many worrisome Pareto-K values for the best-fitting model based on LOOIC.

The full set of models in a separate script (`02_models.R`); I'll present the results here. Of note, we also used a Student's-t distribution to model variance as a response variable, despite indications from posterior predictive checks that a skew-Gaussian distribution might be more appropriate. However, a skew-Gaussian distribution suffered from divergent transitions and high Pareto-K values, and both distributions recovered nearly identical estimates of $\beta$, means, and standard deviations, so we stuck with the former. 

First, let's use LOOIC (actually expected log predictive density, or ELPD, but they are just transofrmations of each other) to compare evidence for our hypotheses for predictors of blood slope:

```{r, message=FALSE, warning=FALSE}
loo_slope_hb  <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_hb_loo_elpd.csv")
print(loo_slope_hb)
loo_slope_hct  <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_hct_loo_elpd.csv")
print(loo_slope_hct)
loo_slope_MCHC  <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_hct_loo_elpd.csv")
print(loo_slope_MCHC)
```

These data indicate that the reduced model ($H_{2}$) is a significantly better fit for our data ($elpd_{diff}>2*se_{diff}$) than the both the null model and the full model, but for both hematocrit and MCHC, the null model is a better fit than the full model (though the error is large enough that they aren't distinguishable).

Next, variance:

```{r, message=FALSE, warning=FALSE}
loo_variance_hb  <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_hb_loo_elpd.csv")
print(loo_variance_hb)
loo_variance_hct  <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_hct_loo_elpd.csv")
print(loo_variance_hct)
loo_variance_MCHC  <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_hct_loo_elpd.csv")
print(loo_variance_MCHC)
```

Here, we learn that for all traits, the full model ($H1$) is a significantly better fit than the null model ($H0$). 

Now, let's visualize effect sizes, using our full models in all instances. We'll color code predictors by whether their 95% and 89% credible intervals overlap with 0. 

```{r,message=FALSE}
# read data
slope_full_hb_draws <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_hb.csv")
slope_full_hb_draws <- credibility_coder(slope_full_hb_draws)
slope_full_hct_draws <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_hct.csv")
slope_full_hct_draws <- credibility_coder(slope_full_hct_draws)
slope_full_mchc_draws <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_mchc.csv")
slope_full_mchc_draws <- credibility_coder(slope_full_mchc_draws)
```
```{r, echo=FALSE}
library(tidybayes)

ggplot(data=slope_full_hb_draws, aes(y = .variable, x = .value)) +
  stat_halfeye(aes(fill=credible)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80","darkred","darksalmon"),
                    name="Credible Interval",
                       breaks=c(0, 1, 2),
                       labels=c("NA", "95%", "89%")) +  
  theme_bw() +
  geom_vline(xintercept = 0, linetype="dashed") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_Intercept","b_elev_range","b_median_elevation","b_sampling_range","b_mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Sampling Range","Mass")) +
  ggtitle("Hemoglobin")


ggplot(data=slope_full_hct_draws, aes(y = .variable, x = .value)) +
  stat_halfeye(aes(fill=credible)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80","darkred","darksalmon"),
                    name="Credible Interval",
                       breaks=c(0, 1, 2),
                       labels=c("NA", "95%", "89%")) +
  theme_bw() +
  geom_vline(xintercept = 0, linetype="dashed") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_Intercept","b_elev_range","b_median_elevation","b_sampling_range","b_mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Sampling Range","Mass")) +
  ggtitle("Hematocrit")


ggplot(data=slope_full_mchc_draws, aes(y = .variable, x = .value)) +
  stat_halfeye(aes(fill=credible)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80","darkred","darksalmon"),
                    name="Credible Interval",
                       breaks=c(0, 1, 2),
                       labels=c("NA", "95%", "89%")) +  theme_bw() +
  geom_vline(xintercept = 0, linetype="dashed") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_Intercept","b_elev_range","b_median_elevation","b_sampling_range","b_mass"),
                   labels=c("Intercept","Elev. Range Breadth","Med. Range Elev.", "Sampling Range","Mass")) +
  ggtitle("MCHC")

```

So at the 95% CI level we see a positive effect of median range elevation and elevational range breadth on hemoglobin slope, but not the other parameters. At the 89% CI level, we see a positive effect of median range elevation on hematocrit slope, and a positive effect of elevational range breadth on MCHC slope.

Now, our variance models:

```{r, message=FALSE}
# read data
variance_full_hb_draws <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_hb.csv")
variance_full_hb_draws <- credibility_coder(variance_full_hb_draws)
variance_full_hct_draws <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_hct.csv")
variance_full_hct_draws <- credibility_coder(variance_full_hct_draws)
variance_full_mchc_draws <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_mchc.csv")
variance_full_mchc_draws <- credibility_coder(variance_full_mchc_draws)
```
```{r, echo=FALSE}
ggplot(data=variance_full_hb_draws, aes(y = .variable, x = .value, fill = .variable)) +
  stat_halfeye(aes(fill=credible)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80","darkred","darksalmon"),
                    name="Credible Interval",
                       breaks=c(0, 1, 2),
                       labels=c("NA", "95%", "89%")) +  theme_bw() +
  geom_vline(xintercept = 0, linetype="dashed") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_Intercept","b_range_position","b_edge_distance", "b_bin_elevation"),
                   labels=c("Intercept","Rel. Range Position","Dist. From Edge.", "Bin Elevation")) +
  ggtitle("Hemoglobin")

ggplot(data=variance_full_hct_draws, aes(y = .variable, x = .value, fill = .variable)) +
  stat_halfeye(aes(fill=credible)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80","darkred","darksalmon"),
                    name="Credible Interval",
                       breaks=c(0, 1, 2),
                       labels=c("NA", "95%", "89%")) +  theme_bw() +
  geom_vline(xintercept = 0, linetype="dashed") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_Intercept","b_range_position","b_edge_distance", "b_bin_elevation"),
                   labels=c("Intercept","Rel. Range Position","Dist. From Edge.", "Bin Elevation")) + 
  ggtitle("Hematocrit")


ggplot(data=variance_full_mchc_draws, aes(y = .variable, x = .value, fill = .variable)) +
  stat_halfeye(aes(fill=credible)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80","darkred","darksalmon"),
                    name="Credible Interval",
                       breaks=c(0, 1, 2),
                       labels=c("NA", "95%", "89%")) +  theme_bw() +
  geom_vline(xintercept = 0, linetype="dashed") +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_Intercept","b_range_position","b_edge_distance", "b_bin_elevation"),
                   labels=c("Intercept","Rel. Range Position","Dist. From Edge.", "Bin Elevation")) +
  ggtitle("MCHC")

```

We see that elevation and edge distance have positive effects on the coefficient of variance of hemoglobin at the 95% CI level; that elevation and edge distance and relative range position have positive effects on the coefficient of variance of hematocrit at the 95% CI level; and that edge distance has a positive effect on the coefficient of variance of MCHC at the 89% CI level. 

Fin!