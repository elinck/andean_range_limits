---
title: "Andean bird blood data analysis"
output: 
  pdf_document:
  latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
local({
  hook_inline = knitr::knit_hooks$get('inline')
  knitr::knit_hooks$set(inline = function(x) {
    res = hook_inline(x)
    if (is.numeric(x)) sprintf('$%s$', res) else res
  })
})
```

### Introduction

What constrains elevational range limits in the absence of an ecotone or obvious biotic constraints? One *abiotic* factor that falls under what Terborgh& Weske (1975) called constraints that vary "continuously and in parallel with the elevational gradient" is the partial pressure of oxygen (PO2), which declines roughly linearly with altitude and is an strong selective pressure.

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.height=4,fig.width=8}
# libraries
library(ggplot2)
library(cowplot)
library(tidyverse, quietly = TRUE)

# load functions script
source("~/Dropbox/andean_range_limits/scripts/00_functions.R")

# calculate water vapor pressure based on temperature and humidity
wvp <- water_vapor_pressure(temp_celsius = 15, humidity = 20)

# assign coefficients for formulae
sea_level_pressure <- 760 # in mmHg
mass <- 0.0289644 # molar mass of gas in kg/mol
gravity <- 9.81 # acceleration due to gravity in m/s2
gas_constant <- 8.3145 #J/molK
temp_kelvin <- 15 + 273.15 # assuming 15C here
mbar_conversion <- 1.33322 # convert mmHg to mbar
o2 <- 0.2095 # proportion o2 in atmosphere
max_o2 <- ((sea_level_pressure*exp(-(mass*gravity)/(gas_constant*temp_kelvin)*0)*mbar_conversion)-wvp)*o2

# barometric formula
p <- function(x) sea_level_pressure *exp(-(mass*gravity)/(gas_constant*temp_kelvin)*x)*mbar_conversion
o <- function(x) ((sea_level_pressure*exp(-(mass*gravity)/(gas_constant*temp_kelvin)*x)*mbar_conversion)-wvp)*o2
po2 <-function(x) (((sea_level_pressure*exp(-(mass*gravity)/(gas_constant*temp_kelvin)*x)*mbar_conversion)-wvp)*o2/max_o2)*100

p1 <- ggplot(data = data.frame(x = 0), mapping = aes(x = x)) +
  theme_bw() +
  stat_function(fun = p, aes(linetype="Atmospheric Pressure")) +
  stat_function(fun = o, aes(linetype="PO2")) +
  scale_linetype_discrete(labels=c("Atm", 
                                   expression(PO[2]))) +
  theme(panel.grid = element_blank()) +
  xlim(0,8000) +
  #ylim(0,1200) +
  xlab("Elevation (m)") +
  ylab("Millibars") +
  labs(linetype=element_blank()) +
  theme(legend.position = c(0.8, 0.8))

p2 <- ggplot(data = data.frame(x = 0), mapping = aes(x = x)) +
  theme_bw() +
  stat_function(fun = po2) +
  scale_linetype_discrete(guide=FALSE) +
  theme(panel.grid = element_blank()) +
  xlim(0,9500) +
  ylim(0,100) +
  geom_vline(xintercept = 1619, size=3, alpha=0.3) +
  geom_text(aes(x=1319, label="Albuquerque, NM: 82%", y=20), angle=90, size=3) +
  geom_vline(xintercept = 3982, size=3, alpha=0.2) +
  geom_text(aes(x=3682, label="Mt. Wheeler, NM: 62%", y=20), angle=90, size=3) +
  geom_vline(xintercept = 6768, size=3, alpha=0.1) +
  geom_text(aes(x=6468, label="Huascarán, Peru: 44%", y=20), angle=90, size=3) +
  geom_text(aes(x=8300, label="15°C, 20% humidity", y=100,), size=3) +
  xlab("Elevation (m)") +
  ylab(expression(paste("% sea level ", PO[2]))) +
  labs(linetype=element_blank()) +
  theme(legend.position = c(0.8, 0.9))

plot_grid(p1, p2)
```
In this analysis, we're using a large dataset of blood trait values (total blood hemoglobin concentration, haematocrit, or the volume percentage of red blood cells in blood, and MCHC, or mean cellular hemoglobin concentration) to test the hypothesis that plasticity and variance in these traits is predicted by elevational range breath and position—a pattern which would suggest a causal relationship between adaptative changes in proxies for blood oxygen carrying capacity and the elevational distribution of bird species. 

This dataset is derived from measurements associated with vouchered specimens collected across the Peru by Museum of Southwestern Biology (Albuquerque, NM, USA) and Centro de Ornitología y Biodiversidad (Lima, Peru) staff, research affiliates, and collaborators from 2006 to 2020. As typical of the tropics worldwide, these species have disproportionately narrow elevational ranges. How narrow, you ask? Here's a visualization of the distribution of elevational range breadth using data from the 3,752 neotropical bird  species in [Parker et al. 1996](https://www.press.uchicago.edu/ucp/books/book/chicago/E/bo3618705.html) (what Chris calls the "Stotz" data)".

```{r message=FALSE, warning=FALSE}
# load libraries
library(tidyverse, quietly = TRUE)
library(magrittr)
library(ape)
library(phangorn)
library(nlme)
library(phytools)
library(cowplot)
library(mapdata)

# load functions script
source("~/Dropbox/andean_range_limits/scripts/00_functions.R")

# load stotz data
stotz <- read.csv("~/Dropbox/andean_range_limits/data/stotz_elevation_data.csv")
stotz <- cbind.data.frame(stotz$GENUS, stotz$SPECIES, 
                          stotz$MIN, stotz$MAX, stotz$MIDPT.ELEV)
colnames(stotz) <- c("genus","species","elev_min","elev_max","elev_midpt")
stotz$elev_range <- stotz$elev_max - stotz$elev_min
stotz_mod <- stotz[stotz$elev_range>0,]
```
```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.height=4, fig.width=7}
p3 <- ggplot(stotz_mod, aes(x=elev_range)) +
  geom_histogram(binwidth = 100, color="black",fill="gray70") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        panel.grid = element_blank()) +
  xlab("elevational range breadth")  +
  geom_vline(xintercept = median(stotz$elev_range, na.rm=TRUE),
             linetype="dashed",size=1.5, color="red")
p3
```

Quite narrow, with strong left skew and a median elevational range breadth of 1100 m.

More specifically, we're interested in the following questions:

1) Is the rate of change (slope) of a blood trait parameter in a given species predicted by its elevational range breadth and / or its median range elevation?

2) Is the variance of a blood trait parameter in a particular elevational band associated with the its absolute elevation or its distance from either an upper or lower range limit?

To begin, we're going to load our data, take a look at it, and make some filtering choices.  

### Cleaning

```{r, message=FALSE, warning=FALSE}
# load data
blood_df <- read.csv("~/Dropbox/andean_range_limits/data/blood_data.csv", 
                     stringsAsFactors = FALSE)

# subset columns of interest
blood_df <- cbind.data.frame(blood_df$Scientific.name, 
                             blood_df$Elevation, 
                             blood_df$Bursa,
                             blood_df$Mass.for.analyses, 
                             blood_df$tHbcorr,
                             blood_df$HctBestEstimate,
                             blood_df$Latitude..degrees.S, 
                             blood_df$Latitude.minutes,
                             blood_df$Longitude.degrees.W, 
                             blood_df$Longitude.minutes,
                             blood_df$Sex)

colnames(blood_df) <- c("species","elevation","bursa","mass","hb","hct", "lat_degrees",
                        "lat_minutes", "long_degrees", "long_minutes", "sex")

# fix longitude minutes error
blood_df$long_minutes <- blood_df$long_minutes %>% as.character() %>% as.numeric()

# fix lat long issue
blood_df$lat <- convert_lat(blood_df)*-1
blood_df$long <- convert_long(blood_df)*-1

# drop sites without locality data 
blood_df <- blood_df[!is.na(blood_df$long),]
blood_df <- blood_df[!is.na(blood_df$lat),]

# drop sites beyond plausible limits of sampling
blood_df <- blood_df[blood_df$lat>(-19),]
blood_df <- blood_df[blood_df$long<(-67),]

# drop old lat long columns
blood_df <- blood_df[,-c(7:10)]

# factor to character nonsense
blood_df$species <- as.character(blood_df$species)
blood_df$elevation <- as.numeric(as.character(blood_df$elevation))
blood_df$hb <-as.numeric(as.character(blood_df$hb))

# drop all missing records (elevation, haemoglobin, haematocrit)
blood_df <- blood_df[!is.na(blood_df$elevation),]
blood_df <- blood_df[!is.na(blood_df$hb),]
blood_df <- blood_df[!is.na(blood_df$hct),]
```

Before we start, where do these records come from, and how are they distributed across elevation?

```{r, fig.height=4, fig.width=8, echo=FALSE}
coast_map <- fortify(map("worldHires", fill=TRUE, plot=FALSE))
p4 <- ggplot() + coord_map() +
  theme_bw() +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  #geom_map(data=coast_map, map=coast_map, aes(x=long, y=lat, map_id=region), 
  #         fill="white", color="black") +
  geom_map(data=data.frame(region="Peru"), map=coast_map,
                    aes(map_id=region), fill="gray100", col="gray0") + 
  xlim(-82,-68) + 
  ylim(-19,0.5) +
  #geom_point(data=df,aes(x=long, y=lat,fill=elev), colour="black",pch=21,alpha=0.3,size = 0.5) + 
  #scale_fill_gradient(low = "white", high = "black") +
  #xlab("longitude") +
  #ylab("latitude") +
  stat_bin2d(data=blood_df, aes(x=long, y=lat,fill = ..count..), color="black", binwidth = c(0.5,0.5)) +
  scale_fill_gradient(low = "white", high = "black") #name = element_blank())

p5 <- ggplot(blood_df, aes(x=elevation)) + geom_histogram(binwidth = 100, color="black",fill="gray70") +
  theme_bw() +
  theme(axis.title.y = element_blank()) +
  xlab("elevation (m)")

plot_grid(p4, p5)
```

Now let's take a look at the head of the dataframe: 

```{r, message=FALSE, warning=FALSE}
# simplified column names
head(blood_df)
```

As you can see, we have columns for species, elevation, presence or absence of a bursa, mass, haemoglobin, haematocrit, collection site longitude and latitude, and sex. As we're also interested in MCHC, let's add a column for that now, using the formula from Campbell and Ellis (thanks, Jessie!)

```{r, message=FALSE, warning=FALSE}
blood_df <- blood_df %>% mutate(hct_percent = hct*100)
blood_df <- blood_df %>% mutate(MCHC_calculated = (hb/hct_percent)*100) # Calculated MCHC
```

Next, let's do some basic filtering, and drop extreme blood parameter values. 

We'll first look at the distribution of blood trait values across all species, using a tidyverse-friendly version of the dataframe:

```{r, message=FALSE, warning=FALSE}
blood_tidy <- blood_df %>% pivot_longer(c(hb, hct, MCHC_calculated), 
                                        names_to = "key", values_to = "value")
```
```{r,message=FALSE, warning=FALSE, echo=FALSE}
p6 <- ggplot(blood_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_x") +
  geom_histogram() +
  theme(panel.grid = element_blank())

p7 <- ggplot(blood_tidy, aes(sample=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_y") +
  stat_qq() +
  theme(panel.grid = element_blank())

plot_grid(p6,p7,nrow=2)
```

Using these plots to inform our cutoffs, let's drop outliers / somewhat normalize distributions:

```{r,  message=FALSE, warning=FALSE}
blood_df_sub <- blood_df[which(blood_df$hb >= 11 &  blood_df$hb <= 24),]
blood_df_sub <- blood_df_sub[which(blood_df_sub$hct >= 0.3 &  
                                     blood_df_sub$hct <= 0.8),]
blood_df_sub <- blood_df_sub[which(blood_df_sub$MCHC_calculated >= 22 
                                   & blood_df_sub$MCHC <= 42),] 
blood_tidy <- blood_df_sub %>% pivot_longer(c(hb, hct, MCHC_calculated), 
                                            names_to = "key", values_to = "value")

```
```{r, message=FALSE, warning=FALSE, echo=FALSE}
p8 <- ggplot(blood_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_x") +
  geom_histogram() +
  theme(panel.grid = element_blank())

p9 <- ggplot(blood_tidy, aes(sample=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_y") +
  stat_qq() +
  theme(panel.grid = element_blank())

plot_grid(p8,p9,nrow=2)
```

Looking much better. We'll then drop species with fewer than 5 records: 

```{r, message=FALSE, warning=FALSE}
sp_list <- c()
for(i in blood_df_sub$species){
  tmp <- blood_df_sub[blood_df_sub$species==i,]
  records <- nrow(tmp)
  if(records > 4){sp_list[i] <- as.character(tmp$species[1])}
}
sp_list <- as.vector(sp_list)

# subset down to "good" species
blood_df_big <- blood_df_sub[blood_df_sub$species %in% sp_list,]

length(unique(blood_df_sub$species)) # number of unique species before filtering
nrow(blood_df_sub) # number of unique records before filtering
length(unique(blood_df_big$species)) # number of unique species after filtering
nrow(blood_df_big) # number of unique records after filtering
```

We'll now merge these datasets with the Stotz data. We're using the parameter `all.x=TRUE`, which just means we aren't going to drop blood data if there's not a taxonomy match with the Stotz table. 

```{r,message=FALSE, warning=FALSE}
stotz$binomial <- paste0(stotz$genus, " ", stotz$species) # create single col for sp.
blood_df_stotz <- merge(blood_df_big, stotz, by.x = "species", by.y = "binomial", 
                        all.x=TRUE)
head(blood_df_stotz)
```

Which species failed to pick up elevational range data?  

```{r,message=FALSE, warning=FALSE}
blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique() %>% length() 
```

Bummer. Let's take a look them:   
 
```{r,message=FALSE, warning=FALSE}
missing <- blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
print(missing)
```


All can be explained by taxonomic changes and / or typos. I've gone directly to a copy of the spreadsheet and made the taxonomy of the Stotz data match to avoid errors from manually entering elevations. We'll now merge again, the revised data: 

```{r, warning=FALSE, message=FALSE}
stotz_rev <- read.csv("~/Dropbox/andean_range_limits/data/stotz_elevation_data_rev.csv")
stotz_rev <- cbind.data.frame(stotz_rev$GENUS, stotz_rev$SPECIES, 
                          stotz_rev$MIN, stotz_rev$MAX, stotz_rev$MIDPT.ELEV)
colnames(stotz_rev) <- c("genus","species","elev_min","elev_max","elev_midpt")
stotz_rev$binomial <- paste0(stotz_rev$genus, " ", stotz_rev$species)
blood_df_stotz <- merge(blood_df_big, stotz_rev, by.x = "species", by.y = "binomial", 
                        all.x=TRUE)
```

Anything still missing?

```{r,message=FALSE, warning=FALSE}
missing <- blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
length(missing)
```

Yep. Let's see  what it is. 

```{r,message=FALSE, warning=FALSE}
blood_df_stotz[is.na(blood_df_stotz$elev_min),]$species %>% unique()
```

Unidentified siskins—we'll drop them.

```{r,message=FALSE, warning=FALSE}
blood_df_stotz <- blood_df_stotz[!blood_df_stotz$species=="Spinus sp.",]
```

We'll next apply a filter to drop probable outliers that could have a disproportionate influence on slope estimation, using my custom `outliers_cooks()` function: points with Cook's D of 4/n, or with a Cook's D of 3.5/n if a bursa is present. 

```{r,message=FALSE, warning=FALSE}
pass_hb <- outliers_cooks(blood_df_stotz, "hb", 4, 3.5)
pass_hct <- outliers_cooks(blood_df_stotz, "hct", 4, 3.5)
pass_mchc <- outliers_cooks(blood_df_stotz, "MCHC_calculated", 4, 3.5)
blood_df_stotz_pass <- intersect(pass_hb, pass_hct, pass_mchc) # get overlapping spp. set
length(unique(blood_df_stotz_pass$species)) # number of unique species
nrow(blood_df_stotz_pass) # retained records
```

For calculating variance down the road, we also need to records based on their relative position in a species' elevational range.

```{r,message=FALSE, warning=FALSE}
# full dataset
vardf <- list()
for(i in unique(blood_df_stotz_pass$species)){
  tmp <- blood_df_stotz_pass[blood_df_stotz_pass$species==i,]
  if(tmp$elev_max > max(tmp$elevation)){elev_max <- unique(tmp$elev_max)}
  if(tmp$elev_max < max(tmp$elevation)){elev_max <- max(tmp$elevation)}
  if(tmp$elev_min < min(tmp$elevation)){elev_min <- unique(tmp$elev_min)}
  if(tmp$elev_min > min(tmp$elevation)){elev_min <- min(tmp$elevation)}
  elev_range <- elev_max - elev_min
  tmp$range_position <- 1-((elev_max-tmp$elevation)/elev_range)
  tmp$edge_distance <- 0.5-abs(tmp$range_position-0.5)
  tmp$elev_range <- elev_range
  tmp$elev_min <- elev_min
  tmp$elev_max <- elev_max
  bin_number <- elev_range %/% 100
  tmp$binID <- cut(tmp$elevation, bin_number)
  vardf[[i]] <- tmp
}
blood_df_stotz_pass <- do.call(rbind, vardf)
```

We're now going to apply a final set of filters to the data (using the function `outliers_limits()`), removing all species with fewer than 2 unique elevational records at least 200 m apart, and fewer than 2 elevational records in the first and last quartile of their range. (This will create the dataframe we'll use for our analysis of the slope of blood parameters—for variance, we'll begin working with a separate dataframe, as we aren't concered with how much of the range these data span.)

```{r,message=FALSE, warning=FALSE}
blood_df_slope <- outliers_limits(blood_df_stotz_pass, min_sample=2, min_limit=2, 200)
length(unique(blood_df_slope$species)) # number of unique species
nrow(blood_df_slope) # number of unique records
```

Let's visualize these slope data (printing large .pdfs elsewhere):  

```{r, message=FALSE, warning=FALSE}
multispecies_hb <- ggplot(blood_df_slope, aes(x=elevation, y=hb)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("hb")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_hb.pdf",width=24,height=20)
multispecies_hb
dev.off()

multispecies_hct <- ggplot(blood_df_slope, aes(x=elevation, y=hct)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("hct")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_hct.pdf",width=24,height=20)
multispecies_hct
dev.off()

multispecies_mchc <- ggplot(blood_df_slope, aes(x=elevation, y=MCHC_calculated)) +
  facet_wrap(~species,scales="free") +
  geom_point(pch=21,stroke=1,aes(color=species),show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="black") +
  theme_bw() +
  xlab("elevation")+
  ylab("mchc")

pdf("~/Dropbox/andean_range_limits/figures/multispecies_mchc.pdf",width=24,height=20)
multispecies_mchc
dev.off()

# save csv of filtered raw data
write.csv(blood_df_slope, "~/Dropbox/andean_range_limits/data/filtered_hb_dataset.csv")
```

Let's take a quick look at patterns in genera with more than two species. First, we'll subset the dataframe. 

```{r, warning=FALSE, message=FALSE}
genus_list <- c()
for(i in unique(blood_df_slope$genus)){
  tmp <- blood_df_slope[blood_df_slope$genus==i,]
  species_num <- unique(tmp$species) %>% length()
  if(species_num>2){genus_list[i] <- as.character(tmp$genus[1])}
}
blood_df_genus <- blood_df_slope[blood_df_slope$genus %in% genus_list,]
```

```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.height=8, fig.width=8}
p10 <- ggplot(blood_df_genus, aes(x=elevation, y=hb)) +
  facet_wrap(~species) +
  geom_point(pch=21,stroke=1,color="black",show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="red") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Elevation")+
  ylab("Hb")

p10
```

Next, let's calculate the slope of hemoglobin and hematocrit—and the average slope angle for different species—using the `blood_slope()` function I've written.  

```{r,message=FALSE, warning=FALSE}
# calculate elevational range and sampling range
blood_df_slope$elev_range <- blood_df_slope$elev_max - blood_df_slope$elev_min

# run function
slope_df <- blood_slope(input_object=blood_df_slope)

# preview data
head(slope_df)

# print number of species 
length(unique(slope_df$species))
```

We'll create a separate dataframe of variance values, using data from the 100m elevational bin with the most observations for any given species with the `blood_variance()` function: 

```{r,message=FALSE, warning=FALSE}
# run function
variance_df <- blood_variance(input_object=blood_df_stotz_pass, min_bin=5) # min of five records per bin to retain
variance_df <- variance_df[complete.cases(variance_df),] # drop incomplete records

# preview data
head(variance_df)

# print number of records
nrow(variance_df)

# print number of species 
length(unique(variance_df$species))
```

Next, we'll load the Jetz supertree so we can control for phylogeny, and then subset the tree down to only those species we have slope data for: 

```{r,message=FALSE, warning=FALSE}
supertree <-read.tree("~/Dropbox/andean_range_limits/data/birds_mcc.tre")
supertree.species <- supertree$tip.label 
slope_df$species <- sub(" ", "_", slope_df$species) 
```

There are a few taxonomic conflicts, which I'll resolve here:

```{r,message=FALSE, warning=FALSE}
slope_df[grep("Arremon_assimilis", slope_df$species),]$species <- "Arremon_torquatus"
slope_df[grep("Myiothlypis_coronata", slope_df$species),]$species <- "Basileuterus_coronatus"
slope_df[grep("Myiothlypis_chrysogaster", slope_df$species),]$species <- "Basileuterus_chrysogaster"
slope_df[grep("Orochelidon_murina", slope_df$species),]$species <- "Notiochelidon_murina"
slope_df[grep("Spinus_magellanicus", slope_df$species),]$species <- "Carduelis_magellanica"
slope_df[grep("Spinus_uropygialis", slope_df$species),]$species <- "Carduelis_uropygialis"
slope_df[grep("Spinus_crassirostris", slope_df$species),]$species <- "Carduelis_crassirostris"
slope_df[grep("Systellura_longirostris", slope_df$species),]$species <- "Caprimulgus_longirostris"
slope_df[grep("Aglaiocercus_kingii", slope_df$species),]$species <- "Aglaiocercus_kingi"
# slope_df[grep("Myiothlypis_luteoviridis", slope_df$species),]$species <- "Basileuterus_luteoviridis"
slope_df[grep("Myiothlypis_nigrocristata", slope_df$species),]$species <- "Basileuterus_nigrocristatus"
slope_df[grep("Pipraeidea_bonariensis", slope_df$species),]$species <- "Thraupis_bonariensis"
slope_df[grep("Premnornis_guttuliger", slope_df$species),]$species <- "Premnornis_guttuligera"
slope_df[grep("Ceratopipra_chloromeros", slope_df$species),]$species <- "Pipra_chloromeros"
slope_df[grep("Thamnophilus_bernardi", slope_df$species),]$species <- "Sakesphorus_bernardi"
slope_df[grep("Cercomacroides_serva", slope_df$species),]$species <- "Cercomacra_serva"
# slope_df[grep("Chloropipo_unicolor", slope_df$species),]$species <- "Xenopipo_unicolor"


# prune tree
slope.tree <- keep.tip(supertree, slope_df$species)

# write to files
write.csv(slope_df, file="~/Dropbox/andean_range_limits/data/blood_slopes.csv")
write.tree(slope.tree, file="~/Dropbox/andean_range_limits/data/blood_slope.tre")
```

And then the same thing for our variance data: 

```{r,message=FALSE, warning=FALSE}
variance_df$species <- sub(" ", "_", variance_df$species) 
variance_df[grep("Myiothlypis_coronata", variance_df$species),]$species <- "Basileuterus_coronatus"
variance_df[grep("Myiothlypis_luteoviridis", variance_df$species),]$species <- "Basileuterus_luteoviridis"
variance_df[grep("Spinus_magellanicus", variance_df$species),]$species <- "Carduelis_magellanica"
variance_df[grep("Spinus_uropygialis", variance_df$species),]$species <- "Carduelis_uropygialis"
variance_df[grep("Aglaiocercus_kingii", variance_df$species),]$species <- "Aglaiocercus_kingi"
variance_df[grep("Pipraeidea_bonariensis", variance_df$species),]$species <- "Thraupis_bonariensis"
variance_df[grep("Pheugopedius_eisenmanni", variance_df$species),]$species <- "Thryothorus_eisenmanni"
variance_df[grep("Thamnophilus_bernardi", variance_df$species),]$species <- "Sakesphorus_bernardi"

# prune tree
variance.tree <- keep.tip(supertree, variance_df$species)

# write to files
write.csv(variance_df, file="~/Dropbox/andean_range_limits/data/blood_variances.csv")
write.tree(variance.tree, file="~/Dropbox/andean_range_limits/data/blood_variances.tre")
```

Before moving on to model fitting, let's visualize the distribution of blood parameter slopes and variances—a key descriptive contribution of the study:

```{r,message=FALSE, warning=FALSE}
# tidy dataframe
slope_tidy <- slope_df %>% pivot_longer(c(slope_hb, slope_hct, slope_mchc), 
                                         names_to = "key", values_to = "value")

# change facet labels
slope_tidy$key <- factor(slope_tidy$key)
levels(slope_tidy$key) <- c("Hb", "Hct", "MCHC")

# estimate medians
median_hb <- slope_tidy[slope_tidy$key=="Hb",]$value %>% median()
median_hct <- slope_tidy[slope_tidy$key=="Hct",]$value %>% median()
median_mchc <- slope_tidy[slope_tidy$key=="MCHC",]$value %>% median()
```
```{r, echo=FALSE, warning=FALSE, message=FALSE}
# plot
p11 <- ggplot(slope_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key, scales="free_x") +
  geom_histogram(bins=50, fill=NA, color="black") +
  geom_vline(data=filter(slope_tidy, key=="Hb"), aes(xintercept=median_hb), colour="red",
             linetype="dashed") + 
  geom_vline(data=filter(slope_tidy, key=="Hct"), aes(xintercept=median_hct), colour="red",
             linetype="dashed") + 
    geom_vline(data=filter(slope_tidy, key=="MCHC"), aes(xintercept=median_mchc), colour="red",
             linetype="dashed") + 
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Slope") +
  ylab("Count")

p11
```

This shows us the median slope value for change in Hb or Hct is greater than 0, but is difficult to tell for MCHC. Let's do a quick and dirty test of this:

```{r,message=FALSE, warning=FALSE}
# shapiro test to see if t-test is appropriate (e.g. data are normally distributed)
shapiro.test(slope_df$slope_hb) # W = 0.8944, p-value = 5.76e-08
shapiro.test(slope_df$slope_hct) # W = 0.8876, p-value = 2.647e-08
shapiro.test(slope_df$slope_mchc) # W = 0.88046, p-value = 1.206e-08

# all fail, so wilcox test better
wilcox.test(slope_df$slope_hb) # V = 5495, p-value = 0.0002752
wilcox.test(slope_df$slope_hct) # V = 5666, p-value = 5.037e-05
wilcox.test(slope_df$slope_mchc) # V = 4031, p-value = 0.9418
```

As expected, the slope values for Hb and Hct are significantly greater than 0, but those for MCHC are not. What's going on with variance?

```{r,message=FALSE, warning=FALSE}
# tidy dataframe
variance_tidy <- variance_df %>% pivot_longer(c(variance_hb, variance_hct, variance_mchc), 
                                         names_to = "key", values_to = "value")
```

```{r,message=FALSE, warning=FALSE, echo=FALSE}
# change facet labels
variance_tidy$key <- factor(variance_tidy$key)
levels(variance_tidy$key) <- c("Hb", "Hct", "MCHC")

# estimate medians
median_hb <- variance_tidy[variance_tidy$key=="Hb",]$value %>% median()
median_hct <- variance_tidy[variance_tidy$key=="Hct",]$value %>% median()
median_mchc <- variance_tidy[variance_tidy$key=="MCHC",]$value %>% median()
```
```{r, echo=FALSE, warning=FALSE, message=FALSE}
# plot
p12 <- ggplot(variance_tidy, aes(x=value)) + 
  theme_bw() +
  facet_wrap(~key) +
  geom_histogram(bins=50, fill=NA, color="black") +
  geom_vline(data=filter(variance_tidy, key=="Hb"), aes(xintercept=median_hb), colour="red",
             linetype="dashed") + 
  geom_vline(data=filter(variance_tidy, key=="Hct"), aes(xintercept=median_hct), colour="red",
             linetype="dashed") + 
    geom_vline(data=filter(variance_tidy, key=="MCHC"), aes(xintercept=median_mchc), colour="red",
             linetype="dashed") + 
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Variance") +
  ylab("Count")

p12 
```

Looks like the variance of the coefficient of variation (lol) is normalish, with one fat tail, and left-skewed.

And let's also make scatter plots of everything I find interesting:  

```{r, message=FALSE, warning=FALSE, fig.height=9,fig.width=7, echo=FALSE}
p13 <- ggplot(slope_tidy, aes(x=elev_range, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
  geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  ylab("Slope") +
  xlab("Elevational Range Breadth")

p14 <- ggplot(slope_tidy, aes(x=median_elevation, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
  geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  ylab("Slope") +
  xlab("Median Range Elevation")

p15 <- ggplot(variance_tidy, aes(x=edge_distance, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
 # geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
    ylab("Variance") +
  xlab("Edge Distance")

p16 <- ggplot(variance_tidy, aes(x=bin_elevation, y=value)) +
  theme_bw() +
  facet_wrap(~key, scales = "free_y") +
  geom_point(pch=21) +
  # geom_hline(yintercept = 0, color="red", linetype="dashed") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
    ylab("Variance") +
  xlab("Bin Elevation")

plot_grid(p13, p14, p15, p16, labels="AUTO", nrow=4)

```

Interesting, some vague hints of patterns—but what does it mean? 

To tackle that' we're going to build generative Bayesian models using Stan implemented in the R package `brms`. Specifically, we're going to test the following (generalized) hypotheses:

#### Slope  

$H_{0}$: The slope of change in blood parameter values is unrelated to predictors (elevational range breadth, median range elevation, sampling range, mass, and the interaction of elevational range breadth and median range elevation) and best explained by phylogeny alone.

$H_{1}$: The slope of change in blood parameter values is best explained by all predictors and phylogeny 

$H_{2}$: The slope of change in blood parameter values is best explained by the predictors without controlling for phylogeny

$H_{3}$: The slope of change in blood parameter values is best explained by the predictors without controlling for phylogeny or including a term for the interaction of elevational range breadth and median range elevation

#### Variance

$H_{0}$: Variance in a given 100 m elevation bin is unrelated to predictors (distance from range edge, median bin elevation, and the interaction of distance from range edge and median bin elevation) and best explained by phylogeny alone

$H_{1}$: Variance in a given 100 m elevation bin is best explained by all predictors and phylogeny

$H_{2}$: Variance in a given 100 m elevation bin is explained by a subset of predictors without controlling for phylogeny  

$H_{2}$: Variance in a given 100 m elevation bin is explained by a subset of predictors without controlling for phylogeny or including a term for the interaction of distance from range edge and median bin elevation

Each of these hypotheses is associated with a model with a corresponding variable name and number in the script `02_models.R`. For example, the model fit to slope of change in hemoglobin that includes all predictors and controls for phylogeny is saved as an object named `slope_hb_2`; the null model for variance in MCHC is titled `variance_mchc_0`, etc. 

Formally, the full model predicting slope of change in a given blood parameter across elevation is defined as follows:

$$
\begin{split}
S_{EST,i} \sim Normal(\mu_{i},\sigma) \\
\mu_{i} = \alpha + \alpha_{j} + \beta_{R}R_{i} + \beta_{E}E_{i} + \beta_{P}P_{i} + \beta_{M}M_{i} + \beta_{RE}R_{i}E_{i}  \\
S_{OBS,i} \sim Normal(S_{EST,i}, S_{SE,i}) \\
\alpha \sim Normal(0,10) \\
\alpha_{j} \sim Normal(\alpha, \sigma_{A}) \\
\beta_{R} \sim Normal(0,2.5) \\
\beta_{E} \sim Normal(0,2.5) \\
\beta_{P} \sim Normal(0,2.5) \\
\beta_{M} \sim Normal(0,2.5) \\
\beta_{RE} \sim Normal(0,2.5) \\
\sigma \sim Cauchy(0,2.5) \\
\end{split}
$$
where $R$ is range width, $E$ is median range elevation, $M$ is mass, $P$ is sampling range (the sampled proportion of total estimated elevational range) and $A$ is a covariance matrix of phylogenetic distance among taxa. Note that we model measurement error by incorporating observed standard error from the simple linear regressions we ran to estimate slope in the first place in the third line of the model ($S_{SE,i}$), which you can consider the prior probability for our observations, with the first line now representing a "likelihood" for our estimates. 

Our basic model for blood trait variance is similar, though this time we do not model measurement error: 

$$
\begin{split}
\mu_{i} = \alpha + \alpha_{j} + \beta_{E}E_{i} + \beta_{D}E_{i} + \beta_{ED}E_{i}D_{i}  \\
\alpha \sim Normal(0,10) \\
\alpha_{j} \sim Normal(\alpha, \sigma_{A}) \\
\beta_{E} \sim Normal(0,2.5) \\
\beta_{D} \sim Normal(0,2.5) \\
\beta_{ED} \sim Normal(0,2.5) \\
\sigma \sim Cauchy(0,2.5) \\
\end{split}
$$

Here, $E$ is median bin elevation, $D$ is distance from range edge, and $A$ is again the phylogenetic distance matrix. 

After running these models and assessing proper convergence, we want to 1) visualize effect sizes; 2) visualize posterior predictive power; 3) visualize trend lines from the posterior using counterfactuals; and 4) visualize interaction effect using triptychs. 

Let's start by looking at LOOIC values for all the models:

```{r, warning=FALSE, mess=FALSE}
slope_hb_loo <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_hb_loo_elpd.csv")
slope_hb_loo
```
So for the slope of change in hemoglobin, the model *without* or controlling for phylogeny is best—though the standard error is large enough we can't be very confident in that. 

```{r, warning=FALSE, mess=FALSE}
slope_hct_loo <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_hct_loo_elpd.csv")
slope_hct_loo
```
For the slope of change in hematocrit, the null model is the best—though again, SEs are large. 

```{r, warning=FALSE, mess=FALSE}
slope_mchc_loo <- read_csv("~/Dropbox/andean_range_limits/data/slope_full_mchc_loo_elpd.csv")
slope_mchc_loo
```
For the slope of change in MCHC, the null model is again best, and the SEs are again large. 

```{r, warning=FALSE, mess=FALSE}
variance_hb_loo <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_hb_loo_elpd.csv")
variance_hb_loo 
```

For variance within a given elevational band in hemoglobin, the model with an interaction term but without predictors is best, with large SEs. 

```{r, warning=FALSE, mess=FALSE}
variance_hct_loo <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_hct_loo_elpd.csv")
variance_hct_loo 
```

For variance within a given elevational band in hematocrit, the model without and interaction term and without predictors is best, and we can be fairly confident in the improvement over the null. 

```{r, warning=FALSE, mess=FALSE}
variance_mchc_loo <- read_csv("~/Dropbox/andean_range_limits/data/variance_full_mchc_loo_elpd.csv")
variance_mchc_loo 
```

For variance within a given elevational band in MCHC, the model without and interaction term and without predictors is best, but the SE associated with that difference is large. 

Next, let's visualize effect sizes for the best-fit models. We'll start with the slope model for hemoglobin:

```{r, warning=FALSE, message=FALSE}
library(brms)
library(tidybayes)
library(modelr)

# load draws and evaluate levels of support for different variables with function
slope_hb_draws <- read_csv("~/Dropbox/andean_range_limits/data/slope_hb_draws_interaction.csv") %>% 
  credibility_coder()

# create data frame assiging variables to credibility levels
credibility <- slope_hb_draws %>% distinct(.variable, credible)

# calculate width for point interval probabilities
slope_hb_draws <- slope_hb_draws %>% 
  group_by(.variable) %>% 
  median_hdi(.value, .width = c(.95, .8, .5)) %>%
  group_by(.variable) %>% 
  mutate(condition_mean = mean(.value)) 

# merge dataframe with credibilty levels
slope_hb_draws <- merge(slope_hb_draws, credibility, by.x = ".variable", by.y = ".variable")
```
```{r, echo=FALSE, fig.height=4,fig.width=6}
p17 <- ggplot(slope_hb_draws, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","89%")) +  
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab(expression(paste(Beta,"*",10^{3}))) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_elev_range_s","b_median_elevation_s","b_sampling_range_s","b_mass_s", "b_elev_range_s:median_elevation_s"),
                   labels=c("Elev. Range","Range Elev.", "Sampling Range","Mass", "Elev. Range * Range Elev.")) +
  ggtitle("Hemoglobin")

p17
```

We see a positive effect of elevational range breadth on slope of change in hemoglobin concentration, credible at the 89% level, but no other credible effects.

Let's continue on to hematocrit. 

```{r, message=FALSE, warning=FALSE}
# load draws and evaluate levels of support for different variables with function
slope_hct_draws <- read_csv("~/Dropbox/andean_range_limits/data/slope_hct_draws.csv") %>% 
  credibility_coder()

# create data frame assiging variables to credibility levels
credibility <- slope_hct_draws %>% distinct(.variable, credible)

# calculate width for point interval probabilities
slope_hct_draws <- slope_hct_draws %>% 
  group_by(.variable) %>% 
  median_hdi(.value, .width = c(.95, .8, .5)) %>%
  group_by(.variable) %>% 
  mutate(condition_mean = mean(.value)) 

# merge dataframe with credibilty levels
slope_hct_draws <- merge(slope_hct_draws, credibility, by.x = ".variable", by.y = ".variable")
```
```{r, echo=FALSE, fig.height=4,fig.width=6}
p18 <- ggplot(slope_hct_draws, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","89%")) +  
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab(expression(paste(Beta,"*",10^{1}))) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_elev_range_s","b_median_elevation_s","b_sampling_range_s","b_mass_s", "b_elev_range_s:median_elevation_s"),
                   labels=c("Elev. Range","Range Elev.", "Sampling Range","Mass", "Elev. Range * Range Elev.")) +
  ggtitle("Hematocrit")

p18
```
We find no credible effects for slope of change in hematocrit. 

```{r, message=FALSE, warning=FALSE}
# load draws and evaluate levels of support for different variables with function
slope_mchc_draws <- read_csv("~/Dropbox/andean_range_limits/data/slope_mchc_draws.csv") %>% 
  credibility_coder()

# create data frame assiging variables to credibility levels
credibility <- slope_mchc_draws %>% distinct(.variable, credible)

# calculate width for point interval probabilities
slope_mchc_draws <- slope_mchc_draws %>% 
  group_by(.variable) %>% 
  median_hdi(.value, .width = c(.95, .8, .5)) %>%
  group_by(.variable) %>% 
  mutate(condition_mean = mean(.value)) 

# merge dataframe with credibilty levels
slope_mchc_draws <- merge(slope_mchc_draws, credibility, by.x = ".variable", by.y = ".variable")
```
```{r, echo=FALSE, fig.height=4,fig.width=6}
p19 <- ggplot(slope_mchc_draws, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","89%")) +  
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab(expression(paste(Beta,"*",10^{1}))) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_elev_range_s","b_median_elevation_s","b_sampling_range_s","b_mass_s", "b_elev_range_s:median_elevation_s"),
                   labels=c("Elev. Range","Range Elev.", "Sampling Range","Mass", "Elev. Range * Range Elev.")) +
  ggtitle("MCHC")

p19
```
...and no credible effects for the slope of change in MCHC.

So to summarize, we see that **elevational range breadth** and **median range elevation** are reasonable predictors of slope of change in concentration in hemoglobin, with effects that are slightly masked by a negative interaction. We have no good predictors of the slope of change in hematocrit or MCHC. 

Let's make some "counterfactual" plots to visualize the contribution of elevational range breadth or median range elevation to slope of change in hemoglobin when all other variables but the predictor of interest are held constant:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# load counterfactual data
counter_range_hb <- read_csv("~/Dropbox/andean_range_limits/data/slope_hb_range_counter.csv")
counter_elev_hb <- read_csv("~/Dropbox/andean_range_limits/data/slope_hb_median_counter.csv")

# load slope dataframe from models
slope_df_m <- read_csv("~/Dropbox/andean_range_limits/data/blood_slopes_m.csv")
```
```{r, echo=FALSE, fig.height=4,fig.width=4}
# plot
p20 <- ggplot(counter_range_hb, aes(x = elev_range_s, y = Estimate)) +
  geom_ribbon(aes(ymin = p_ll, ymax = p_ul),
              fill = "gray10", alpha = 1/5) +
  geom_smooth(aes(ymin = f_ll, ymax = f_ul),
              stat = "identity",
              fill = "gray10", color = "gray40", alpha = 1/5, size = 1/4) +
  geom_point(data=slope_df_m, aes(x=elev_range_s, y=slope_hb), pch=21) +
  coord_cartesian(xlim = range(slope_df_m$elev_range_s),
                  ylim = range(slope_df_m$slope_hb)) +
  labs(y = expression(paste(Delta, " [Hb] * ",10^{3})),
       x  = "Elevational Range Breadth (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank())  

p20
```

A positive, linear effect; lots of uncertainty. 

Next, let's look at effect sizes from our variance models, in the same order:

```{r, message=FALSE, warning=FALSE}
# load draws and evaluate levels of support for different variables with function
variance_hb_draws <- read_csv("~/Dropbox/andean_range_limits/data/variance_hb_draws.csv") %>%
  credibility_coder()

# create data frame assiging variables to credibility levels
credibility <- variance_hb_draws %>% distinct(.variable, credible)

# calculate width for point interval probabilities
variance_hb_draws <- variance_hb_draws %>% 
  group_by(.variable) %>% 
  median_hdi(.value, .width = c(.95, .8, .5)) %>%
  group_by(.variable) %>% 
  mutate(condition_mean = mean(.value)) 

# merge dataframe with credibilty levels
variance_hb_draws <- merge(variance_hb_draws, credibility, by.x = ".variable", by.y = ".variable")
```
```{r, echo=FALSE, fig.height=4,fig.width=6}
p21 <- ggplot(variance_hb_draws, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","89%")) +  
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_bin_elevation_s","b_edge_distance_s","b_bin_elevation_s:edge_distance_s"),
                   labels=c("Elevation","Distance from Edge", "Elevation * Distance from Edge")) +
  ggtitle("Hemoglobin")

p21
```
So a positive effect of distance from either range limit on the coefficient of variation, a negative effect of absolute elevation, and a negative interaction term. Next, hematocrit: 

```{r, message=FALSE, warning=FALSE}
# load draws and evaluate levels of support for different variables with function
variance_hct_draws <- read_csv("~/Dropbox/andean_range_limits/data/variance_hct_draws.csv") %>% 
  credibility_coder()

# create data frame assiging variables to credibility levels
credibility <- variance_hct_draws %>% distinct(.variable, credible)

# calculate width for point interval probabilities
variance_hct_draws <- variance_hct_draws %>% 
  group_by(.variable) %>% 
  median_hdi(.value, .width = c(.95, .8, .5)) %>%
  group_by(.variable) %>% 
  mutate(condition_mean = mean(.value)) 

# merge dataframe with credibilty levels
variance_hct_draws <- merge(variance_hct_draws, credibility, by.x = ".variable", by.y = ".variable")
```
```{r, echo=FALSE, fig.height=4,fig.width=6}
p22 <- ggplot(variance_hct_draws, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","85%")) +  
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_bin_elevation_s","b_edge_distance_s","b_bin_elevation_s:edge_distance_s"),
                   labels=c("Elevation","Distance from Edge", "Elevation * Distance from Edge")) +
  ggtitle("Hematocrit")

p22
```
Similar, but not identical, results. Lastly, MCHC: 

```{r, message=FALSE, warning=FALSE}
# load draws and evaluate levels of support for different variables with function
variance_mchc_draws <- read_csv("~/Dropbox/andean_range_limits/data/variance_mchc_draws.csv") %>%
  credibility_coder()

# create data frame assiging variables to credibility levels
credibility <- variance_mchc_draws %>% distinct(.variable, credible)

# calculate width for point interval probabilities
variance_mchc_draws <- variance_mchc_draws %>% 
  group_by(.variable) %>% 
  median_hdi(.value, .width = c(.95, .8, .5)) %>%
  group_by(.variable) %>% 
  mutate(condition_mean = mean(.value)) 

# merge dataframe with credibilty levels
variance_mchc_draws <- merge(variance_mchc_draws, credibility, by.x = ".variable", by.y = ".variable")
```
```{r, echo=FALSE, fig.height=4,fig.width=6}
p23 <- ggplot(variance_mchc_draws, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","89%")) +  
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab(expression(Beta)) +
  ylab(element_blank()) + 
  scale_y_discrete(breaks=c("b_bin_elevation_s","b_edge_distance_s","b_bin_elevation_s:edge_distance_s"),
                   labels=c("Elevation","Distance from Edge", "Elevation * Distance from Edge")) +
  ggtitle("MCHC")

p23
```
In contrast, very little signal here.

As with our slope data, let's make counterfactual plots for credible effects and interactions. We'll start with hemoglobin:

```{r, warning=FALSE, message=FALSE}
# load counterfactual data
counter_edge_hb <- read_csv("~/Dropbox/andean_range_limits/data/variance_hb_edge_counter.csv")
counter_bin_hb <- read_csv("~/Dropbox/andean_range_limits/data/variance_hb_bin_counter.csv")

# load slope dataframe from models
variance_df_m <- read_csv("~/Dropbox/andean_range_limits/data/blood_variance_m.csv")
```

```{r, echo=FALSE, fig.height=4,fig.width=4}
# plot
p24 <- ggplot(counter_edge_hb, aes(x = edge_distance_s, y = Estimate)) +
  geom_ribbon(aes(ymin = p_ll, ymax = p_ul),
              fill = "gray10", alpha = 1/5) +
  geom_smooth(aes(ymin = f_ll, ymax = f_ul),
              stat = "identity",
              fill = "gray10", color = "gray40", alpha = 1/5, size = 1/4) +
  geom_point(data=variance_df_m, aes(x=edge_distance_s, y=variance_hb), pch=21) +
  coord_cartesian(xlim = range(variance_df_m$edge_distance_s),
                  ylim = range(variance_df_m$variance_hb)) +
  labs(y = expression(paste("Variance [Hb] * ",10^{2})),
       x  = "Distance from Range Edge (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank())    

p24
```

```{r, echo=FALSE, fig.height=4,fig.width=4}
p25 <- ggplot(counter_bin_hb, aes(x = bin_elevation_s, y = Estimate)) +
  geom_ribbon(aes(ymin = p_ll, ymax = p_ul),
              fill = "gray10", alpha = 1/5) +
  geom_smooth(aes(ymin = f_ll, ymax = f_ul),
              stat = "identity",
              fill = "gray10", color = "gray40", alpha = 1/5, size = 1/4) +
  geom_point(data=variance_df_m, aes(x=bin_elevation_s, y=variance_hb), pch=21) +
  coord_cartesian(xlim = range(variance_df_m$bin_elevation_s),
                  ylim = range(variance_df_m$variance_hb)) +
  labs(y = expression(paste("Variance [Hb] * ",10^{2})),
       x  = "Bin Elevation (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank()) 

p25
```

Now, the interaction of these variables: 

```{r, message=FALSE, warning=FALSE}
# load interaction data
variance_hb_interaction <- read_csv("~/Dropbox/andean_range_limits/data/variance_hb_interaction.csv")

# subset to only 3 values of bin_elevation
variance_hb_interaction <- variance_hb_interaction %>% filter(bin_elevation_s==(-2) | 
                                                                bin_elevation_s==0 |
                                                                bin_elevation_s==2)

# turn panels into factors
variance_hb_interaction$panel <- as.factor(variance_hb_interaction$panel)

# rename panels
variance_hb_interaction$panel <- plyr::revalue(variance_hb_interaction$panel, c("panel_-2"="Bin Elev. = -2", 
                                "panel_0"="Bin. Elev = 0",
                                "panel_2"="Bin. Elev = +2"))
```
```{r, echo=FALSE, fig.height=4,fig.width=6}
# plot
p26 <- ggplot(variance_hb_interaction, aes(x = edge_distance_s)) +
  geom_smooth(aes(y = Estimate, ymin = p_ll, ymax = p_ul),
              stat = "identity", 
              fill = "gray40", color = "gray40", alpha = 1/5, size = 1/2) +
  geom_ribbon(aes(ymin = f_ll, ymax = f_ul),
              fill = "gray10", alpha = 1/5) +
  geom_point(data=variance_df_m, aes(x = edge_distance_s, y=variance_hb), pch=21) +
  coord_cartesian(xlim = c(-1.25,1.25), 
                  ylim = range(variance_df_m$variance_hb)) + 
  scale_x_continuous("Edge Distance (Standardized)", breaks = c(-1, 0, 1)) +
  facet_wrap(~panel) +
  labs(y =  "Variance [Hb]", 
       x  = "Edge Distance (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank(),
       strip.background = element_blank())


p26
```

Here, we see that at higher elevations, the positive effect of distance from range edge on the coefficient of variation of hemoglobin values is reduced. 

For hematocrit, we see credible effects of bin elevation and distance from range edge: 

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# load counterfactual data
counter_edge_hct <- read_csv("~/Dropbox/andean_range_limits/data/variance_hct_edge_counter.csv")
counter_bin_hct <- read_csv("~/Dropbox/andean_range_limits/data/variance_hct_bin_counter.csv")
```

```{r, echo=FALSE, fig.height=4,fig.width=4}
# plot
p27 <-ggplot(counter_edge_hb, aes(x = edge_distance_s, y = Estimate)) +
  geom_ribbon(aes(ymin = p_ll, ymax = p_ul),
              fill = "gray10", alpha = 1/5) +
  geom_smooth(aes(ymin = f_ll, ymax = f_ul),
              stat = "identity",
              fill = "gray10", color = "gray40", alpha = 1/5, size = 1/4) +
  geom_point(data=variance_df_m, aes(x=edge_distance_s, y=variance_hct), pch=21) +
  coord_cartesian(xlim = range(variance_df_m$edge_distance_s),
                  ylim = range(variance_df_m$variance_hct)) +
  labs(y = expression(paste("Variance Hct * ",10^{2})),
       x  = "Distance from Range Edge (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank())

p27
```

```{r, echo=FALSE, fig.height=4,fig.width=4}
p28 <- ggplot(counter_bin_hb, aes(x = bin_elevation_s, y = Estimate)) +
  geom_ribbon(aes(ymin = p_ll, ymax = p_ul),
              fill = "gray10", alpha = 1/5) +
  geom_smooth(aes(ymin = f_ll, ymax = f_ul),
              stat = "identity",
              fill = "gray10", color = "gray40", alpha = 1/5, size = 1/4) +
  geom_point(data=variance_df_m, aes(x=bin_elevation_s, y=variance_hct), pch=21) +
  coord_cartesian(xlim = range(variance_df_m$bin_elevation_s),
                  ylim = range(variance_df_m$variance_hct)) +
  labs(y = expression(paste("Variance Hct * ",10^{2})),
       x  = "Bin Elevation (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank())    

p28
```

As previously noted, there's nothing to visualize for MCHC. 

Lastly, let's make production quality figures and tables for the manuscript. We want to get three main points across visually:

1) there is variation in the estimated slope of change in hemoglobin concentration across elevation across phylogeny and within genera;

2) the effect sizes of full models for variance and hemoglobin; 

3) posterior predictive curves and counterfactuals for the most interesting effects.

Starting with 1), let's plot a phylogeny, code slope values by color, and select a few interesting clades to highight: 

```{r, message=FALSE, warning=FALSE}
# load libraries
library(ggtree)
library(tidyverse)
library(viridis)
library(ggstance)
library(png)
library(grid)
library(ggplotify)

# read phylogeny
slope.tree <- read.tree("~/Dropbox/andean_range_limits/data/blood_slope.tre")

# load slope values
slope_df_original  <- read.csv("~/Dropbox/andean_range_limits/data/blood_slopes.csv")

# subset
slope_df <- cbind.data.frame(slope_df_original$species, slope_df_original$slope_hb)

# ready data for plotting
plot_data <- tibble(
  node  = slope_df_original$species,
  median = slope_df_original$median_elevation,
  min = slope_df_original$elev_min,
  max = slope_df_original$elev_max)

# get base tree with annotated slope data
p29 <- ggtree(slope.tree) %<+% slope_df

# add tips; hilight clades
p30 <- ggtree(slope.tree) +
  geom_tippoint(aes(color=p29$data$`slope_df_original$slope_hb`), 
                size=1.5) +
  scale_color_viridis(option="inferno", name="Slope [Hb]") +
  theme_tree2(legend.position=c(.1, .82)) 

# reverse time tree
p31 <- revts(p30)

# tree plot with barplot facet
p32 <- facet_plot(p31,
           panel = "range",
           data = plot_data,
           geom = geom_pointrangeh,
           mapping = aes(xmin=min, 
                         xmax=max, 
                         x=median,
                         width=0.5))

# final plot
p33 <- p32 + 
  geom_hline(yintercept = 27.5, size=3, alpha=0.2) +
  geom_hline(yintercept = 87.5, size=3, alpha=0.2) +
  geom_hline(yintercept = 92.5, size=3, alpha=0.2) +
  geom_hline(yintercept = 131.5, size=3, alpha=0.2) +
  theme(strip.text = element_blank(),
            strip.background = element_blank())

# turn into grob for plotting 
p34 <- as.grob(p33)

# read in hb data, subset
blood_df <- read.csv("~/Dropbox/andean_range_limits/data/filtered_hb_dataset.csv")
select <- c("Oreotrochilus", "Diglossa","Turdus","Spinus")
blood_df_sub <- filter(blood_df, genus %in% select)
blood_df_sub <- blood_df_sub[!blood_df_sub$species=="Diglossa mystacalis",]
blood_df_sub <- blood_df_sub[!blood_df_sub$species=="Spinus crassirostris",]
blood_df_sub <- blood_df_sub[!blood_df_sub$species=="Turdus albicollis",]
blood_df_sub <- blood_df_sub[!blood_df_sub$species=="Turdus serranus",]
blood_df_sub$facet <- factor(blood_df_sub$species, 
                             levels=c("Diglossa cyanea",
                                      "Diglossa brunneiventris",
                                      "Turdus fuscater", 
                                      "Turdus chiguanco", 
                                      "Oreotrochilus estella",
                                      "Oreotrochilus melanogaster",
                                      "Spinus magellanicus",
                                      "Spinus uropygialis"))

# make plot
p35 <- ggplot(blood_df_sub, aes(x=elevation, y=hb)) +
  facet_wrap(~facet, nrow=4) +
  geom_point(pch=21,stroke=1,color="black",show.legend = FALSE) +
  geom_smooth(method="lm",se=FALSE,linetype="dashed",color="red") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank()) +
  xlab("Elevation")+
  ylab("[Hb]")

# load bird pics
p36 <- readPNG("~/Dropbox/andean_range_limits/figures/example_species-01.png")
p36 <- rasterGrob(p36)

# arrange grid
fig_1 <- plot_grid(p34, p35, p36, labels=c("A","B","C"), nrow=1, rel_widths=c(0.4,0.4,0.2))

# write to file
pdf("~/Dropbox/andean_range_limits/figures/figure_1.pdf", height = 6.5, width=11)
fig_1
dev.off()
```

Next, let's make a plot of the distribution of empirical slope and variance values, along with their respective median and 50% interquantile range:

```{r, warning=FALSE, message=FALSE}
# load empirical slope data, manipulate for faceting
slopes_empirical <- read_csv("~/Dropbox/andean_range_limits/data/blood_slopes.csv")
slopes_dist <- slopes_empirical %>% 
  select(slope_hb, slope_hct, slope_mchc) %>% 
  gather()

# calculate quantiles, add linetype legend
slope_quants <- slopes_dist %>% 
  group_by(key) %>% 
  summarise(value = quantile(value, c(0.25, 0.5, 0.75)), 
            q = c(0.25, 0.5, 0.75))
slope_quants <- slope_quants %>% 
  mutate(lt = case_when(
    q == 0.25 ~ "dashed",
    q == 0.5 ~ "solid",
    q == 0.75 ~ "dashed"
  ))

# plot, top row
p37 <- ggplot(slopes_dist, aes(x=value)) + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank(),
        axis.text.y = element_blank(),
        panel.spacing.x = unit(4, "mm")) +
  geom_density(fill="gray40", color="black", alpha=0.5) +
  xlab("Slope") +
  ylab("Density") +
  geom_vline(data=slope_quants, aes(xintercept=value, linetype=lt), color="red") +
  scale_linetype_manual(values = c("dashed", "solid"), guide=FALSE) +
  facet_wrap(~key, scales="free")

# load empirical variance data, manipulate for faceting
variances_empirical <- read_csv("~/Dropbox/andean_range_limits/data/blood_variances.csv")
variances_dist <- variances_empirical %>% 
  select(variance_hb, variance_hct, variance_mchc) %>% 
  gather()

# calculate quantiles, add linetype legend
variance_quants <- variances_dist %>% 
  group_by(key) %>% 
  summarise(value = quantile(value, c(0.25, 0.5, 0.75)), 
            q = c(0.25, 0.5, 0.75))
variance_quants <- variance_quants %>% 
  mutate(lt = case_when(
    q == 0.25 ~ "dashed",
    q == 0.5 ~ "solid",
    q == 0.75 ~ "dashed"
  ))

# plot, top row
p38 <- ggplot(variances_dist, aes(x=value)) + 
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank(),
        axis.text.y = element_blank(),
        panel.spacing.x = unit(4, "mm")) +
  geom_density(fill="gray40", color="black", alpha=0.5) +
  xlab("Variance") +
  ylab("Density") +
  xlim(0,0.25) +
  geom_vline(data=variance_quants, aes(xintercept=value, linetype=lt), color="red") +
  scale_linetype_manual(values = c("dashed", "solid"), guide=FALSE) +
  facet_wrap(~key, scales="free_y")

# combine
fig_2 <- plot_grid(p37, p38, nrow=2, ncol=1, labels=c("A","B"))

# export
pdf("~/Dropbox/andean_range_limits/figures/figure_2.pdf", height = 5, width=9)
fig_2
dev.off()
```

For the paper, let's note the median and IQR values:

```{r, message=FALSE, warning=FALSE}
slope_quants
variance_quants
```

Next, let's plot confidence intervals for predictors for our full models:

```{r, message=FALSE, warning=FALSE}
# assign "variable" column
slope_hb_draws$variable <- "hb_slope"
slope_hct_draws$variable <- "hct_slope"
slope_mchc_draws$variable <- "mchc_slope"
variance_hb_draws$variable <- "hb_variance"
variance_hct_draws$variable <- "hct_variance"
variance_mchc_draws$variable <- "mchc_variance"

# functions to transform values back to "real" effect sizes
scale_hb <- function(x)(x / 1e3)
scale_hct <- function(x)(x / 1e5)
scale_mchc <- function(x)(x / 1e1)

# backtransform tibbles
slope_hb_draws <- slope_hb_draws %>% 
  mutate_at(c(".value",".lower",".upper", "condition_mean"), scale_hb)
slope_hct_draws <- slope_hct_draws %>% 
  mutate_at(c(".value",".lower",".upper","condition_mean"), scale_hct)
slope_mchc_draws <- slope_mchc_draws %>% 
  mutate_at(c(".value",".lower",".upper","condition_mean"), scale_mchc)
variance_hb_draws <- variance_hb_draws %>% 
  mutate_at(c(".value",".lower",".upper","condition_mean"), scale_hb)
variance_hct_draws <- variance_hct_draws %>% 
  mutate_at(c(".value",".lower",".upper","condition_mean"), scale_hct)
variance_mchc_draws <- variance_mchc_draws %>% 
  mutate_at(c(".value",".lower",".upper","condition_mean"), scale_mchc)

# make large dataframe
draws_slope_df <- rbind.data.frame(slope_hb_draws,
                                   slope_hct_draws,
                                   slope_mchc_draws)

draws_variance_df <- rbind.data.frame(variance_hb_draws,
                                   variance_hct_draws,
                                   variance_mchc_draws)

fig_3_top <- ggplot(draws_slope_df, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","89%")) +  
    scale_y_discrete(breaks=c("b_elev_range_s", 
                    "b_median_elevation_s",
                    "b_sampling_range_s",
                    "b_mass_s", 
                    "b_elev_range_s:median_elevation_s"),
                   labels=c("Elev. Range",
                            "Range Elev.", 
                            "Sampling Range",
                            "Mass", 
                            "Elev. Range * Range Elev.")) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position="none") +
  xlab(expression(Beta)) +
  ylab(element_blank()) +
  facet_wrap(~variable, scales="free_x",ncol=1)


fig_3_bottom <- ggplot(draws_variance_df, aes(y = fct_rev(.variable), 
             x=condition_mean, 
             xmin = .lower, 
             xmax = .upper,
             size = -.width)) +
  geom_pointinterval(aes(color=credible)) +
  geom_vline(xintercept = 0, linetype="dashed") +
  scale_color_manual(values = c("black","darkred","darksalmon"),
                    name="Credible Interval",
                    breaks=c(0,1,2),
                    labels=c("NA", "95%","89%")) + 
    scale_y_discrete(breaks=c("b_bin_elevation_s", 
                  "b_edge_distance_s",
                  "b_bin_elevation_s:edge_distance_s"),
                   labels=c("Elev.",
                            "Dist. Edge", 
                            "Elev. * Dist. Edge")) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position="none") +
  xlab(expression(Beta)) +
  ylab(element_blank()) +
  facet_wrap(~variable, scales="free_x", ncol=1)

```

And now to assemble and export:

```{r, message=FALSE, warning=FALSE}
# grab legend object, modify
legend <- get_legend(
  fig_3_bottom +
    guides(color = guide_legend(nrow = 1)) +
    theme(legend.position = "bottom",
          legend.title = element_blank())
)

# build figure
fig_3_nl <- plot_grid(fig_3_top, fig_3_bottom, labels=c("A","B"), ncol=2, rel_widths = c(0.6,0.53))
fig_3 <- plot_grid(fig_3_nl, legend, ncol = 1, rel_heights = c(1, .1))

# export
pdf("~/Dropbox/andean_range_limits/figures/figure_3.pdf", height = 6.5, width=7.5)
fig_3
dev.off()
```

Last, let's revisit the predictions and counterfactuals for the effect of distance from range edge and absolute elevation on variance. This time, we'll transform data back to its proper value:

```{r, message=FALSE, warning=FALSE}
# functions to rescale variance
scale_variance <- function(x)(x / 1e1)

# backtransform tibbles
counter_edge_hb <- counter_edge_hb %>% 
  mutate_at(c("Estimate","Est.Error","f_ll","f_ul","p_ll","p_ul"), scale_variance)
counter_bin_hb <- counter_bin_hb %>% 
  mutate_at(c("Estimate","Est.Error","f_ll","f_ul","p_ll","p_ul"), scale_variance)

# plot
p43 <- ggplot(counter_edge_hb, aes(x = edge_distance_s, y = Estimate)) +
  geom_ribbon(aes(ymin = p_ll, ymax = p_ul),
              fill = "gray10", alpha = 1/5) +
  geom_smooth(aes(ymin = f_ll, ymax = f_ul),
              stat = "identity",
              fill = "gray10", color = "gray40", alpha = 1/5, size = 1/4) +
  geom_point(data=variance_df_m, aes(x=edge_distance_s, y=(variance_hb/1e1)), pch=21) +
  coord_cartesian(xlim = range(variance_df_m$edge_distance_s),
                  ylim = range((variance_df_m$variance_hb/1e1))) +
  labs(y = "Variance [Hb]",
       x  = "Distance from Edge (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank())    

p44 <- ggplot(counter_bin_hb, aes(x = bin_elevation_s, y = Estimate)) +
  geom_ribbon(aes(ymin = p_ll, ymax = p_ul),
              fill = "gray10", alpha = 1/5) +
  geom_smooth(aes(ymin = f_ll, ymax = f_ul),
              stat = "identity",
              fill = "gray10", color = "gray40", alpha = 1/5, size = 1/4) +
  geom_point(data=variance_df_m, aes(x=bin_elevation_s, y=(variance_hb/1e1)), pch=21) +
  coord_cartesian(xlim = range(variance_df_m$bin_elevation_s),
                  ylim = range((variance_df_m$variance_hb/1e1))) +
  labs(y = "Variance [Hb]",
       x  = "Elevation (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank())

fig_4_top <- plot_grid(p43,p44, nrow=1)
```

Now, the interaction of these variables: 

```{r, message=FALSE, warning=FALSE}
# rescale
variance_hb_interaction <- variance_hb_interaction %>% 
  mutate_at(c("Estimate","Est.Error","f_ll","f_ul","p_ll","p_ul"), scale_variance)

fig_4_bottom <- ggplot(variance_hb_interaction, aes(x = edge_distance_s)) +
  geom_smooth(aes(y = Estimate, ymin = p_ll, ymax = p_ul),
              stat = "identity", 
              fill = "gray40", color = "gray40", alpha = 1/5, size = 1/2) +
  geom_ribbon(aes(ymin = f_ll, ymax = f_ul),
              fill = "gray10", alpha = 1/5) +
  geom_point(data=variance_df_m, aes(x = edge_distance_s, y=(variance_hb/1e1)), pch=21) +
  coord_cartesian(xlim = c(-1.25,1.25), 
                  ylim = range((variance_df_m$variance_hb/1e1))) + 
  scale_x_continuous("Distance from Edge (Standardized)", breaks = c(-1, 0, 1)) +
  facet_wrap(~panel) +
  labs(y =  "Variance [Hb]",
       x  = "Distance from Edge (Standardized)") +
  theme_bw() +
  theme(panel.grid = element_blank(),
       strip.background = element_blank())

```

And, at last, we'll export it: 

```{r, warning=FALSE, message=FALSE}
# build figure
fig_4 <- plot_grid(fig_4_top, fig_4_bottom, labels=c("A","B"),ncol = 1)

# export
pdf("~/Dropbox/andean_range_limits/figures/figure_4.pdf", height = 6.5, width=7.5)
fig_4
dev.off()
```

Fin!
